# APEX Functional Specification: The Emergent Orchestration Engine

## 1. Vision: From Prescriptive Framework to Emergent System

The previous model of AI development tools attempts to impose a human-defined structure onto LLMs. We are inverting this.

**APEX's vision is to provide a minimal, robust environment where a primary AI, the Supervisor, can design, build, and evolve its own project-specific development system.**

We are not building the car. We are building the ultimate, intelligent robotic factory that can design and build any car imaginable. Our core belief is that the most efficient and powerful system is one that an LLM designs for itself.

### Key Philosophical Shifts

| Old Paradigm (Prescriptive)                      | New Paradigm (Emergent & Self-Organizing)                                                                    |
| ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |
| APEX defines a strict schema for memory.         | The **Supervisor defines and evolves the schema** for each project, stored within the memory itself.           |
| Agents are "programmed" with complex prompts.    | Agents are given minimal bootstrap prompts that point them to their **role definition and tasks in memory**. |
| The system's logic is hard-coded in Python.      | The system's logic **emerges** from the Supervisor's plans and the evolving schema.                          |
| APEX is the orchestrator.                        | APEX provides the *environment* for the **Supervisor** to be the orchestrator.                               |

## 2. Architecture: The Programmable Workspace

The architecture is simple and powerful. It consists of a Cognitive Layer (Claude instances) and a Memory Layer (LMDB), glued together by a set of primitive tools and a bootstrap process.

```mermaid
graph TD
    subgraph Cognitive Layer (Claude CLI Instances)
        direction LR
        S[üß† Supervisor <br> The System Architect]
        W[‚öôÔ∏è Ephemeral Workers <br> (Coder, Adversary, etc.)]
    end

    subgraph Memory & Tool Layer
        direction LR
        L[üóÑÔ∏è LMDB Programmable Workspace <br> (The World-State)]
        T[üîß Bespoke Utility Toolkit <br> (Python Scripts)]
    end

    User -- "1. High-Level Goal" --> S

    S -- "2. Designs & Manages Schema in LMDB" --> L
    S -- "3. Writes TaskBriefings to LMDB" --> L
    S -- "4. Invokes Workers (with pointers)" --> W
    S -- "6. Invokes Utilities (with args)" --> T

    W -- "5. Adheres to Schema <br> Reads/Writes to LMDB" --> L
    T -- "7. Performs deterministic actions on LMDB" --> L
```

## 3. The Bootstrapping Process: Seeding the System

Since there is no predefined schema, the system's first action is for the Supervisor to define one.

### The Genesis Prompt
The process begins by invoking a single Supervisor `claude` instance with a "Genesis Prompt":

> "You are the Supervisor and chief architect for a new software project. Your first task is to **design the data schema** for your project management and development system within a key-value store (LMDB). Define namespaces for tasks, code, context, issues, and agent communication. Your output for this first task must be a single JSON object representing this schema. Store it in the LMDB at key `/system/schema/v1`."

### The Emergent Schema
The Supervisor's first output is the project's foundational schema. This schema is not fixed; the Supervisor can later decide to evolve it by creating a `/system/schema/v2` and planning a migration.

**Example Initial Schema (Generated by Supervisor):**
```json
{
  "version": "1.0",
  "description": "Schema for the 'API-Builder' project.",
  "namespaces": {
    "plan": "/plan/{sprint}/{goal_id}",
    "tasks": "/tasks/{status}/{task_id}",
    "artifacts": "/artifacts/{type}/{artifact_id}",
    "context": "/context/{content_hash}",
    "comms": "/comms/agents/{agent_id}/inbox"
  },
  "rules": {
    "task_status": ["pending", "active", "review", "done"],
    "artifact_types": ["code", "test", "doc", "report"]
  }
}
```

This self-defined schema now governs all subsequent operations for this specific project.

## 4. Spectrum of Interaction with the LMDB Workspace

Claude agents have a spectrum of methods for interacting with the LMDB, from high-level abstractions to low-level control. The Supervisor intelligently chooses the appropriate method for the task at hand.

| Interaction Method        | How it Works                                                                                             | When to Use                                                                                                | Power vs. Safety         |
| ------------------------- | -------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ------------------------ |
| **High-Level (Utilities)**| `Supervisor` invokes a Python script (`archivist.py`).                                                   | For common, complex, deterministic tasks like summarizing a file or running a test suite.                | **Safest**, Most Abstract    |
| **Mid-Level (MCP Tools)** | `Worker` uses `mcp__lmdb__read` or `mcp__lmdb__write`.                                                     | For standard, atomic database operations. This is the default mode for most task execution.              | **Balanced**, Standard     |
| **Low-Level (Direct Code)** | `Supervisor` generates and executes a `bash` or `python` script that uses the `lmdb` library directly. | For schema creation/evolution, complex data migrations, or optimized queries not covered by MCP tools. | **Most Powerful**, Riskiest |

**Diagram: Spectrum of Interaction**
```mermaid
graph TD
    A[üß† Supervisor] -->|Decides Method| B(Choose Interaction)
    B --> B1{High-Level: Invoke Utility}
    B --> B2{Mid-Level: Use MCP Tool}
    B --> B3{Low-Level: Generate Script}

    B1 --> C1[üîß Bespoke Utility (Python)] -->|Direct Lib Call| D[üóÑÔ∏è LMDB]
    B2 --> C2[‚öôÔ∏è Worker (Claude)] -->|`mcp__lmdb__read`| E[üåê MCP Server] --> D
    B3 --> C3[üìú Generated Script (Python/Bash)] -->|Direct Lib Call| D
```

## 5. Functional Requirements

### 5.1. APEX Core System
The APEX application provides the minimal execution environment.
*   **Process Manager:** A robust system to spawn, monitor, and manage concurrent `claude` CLI and Python subprocesses.
*   **MCP Server:** A lightweight server that exposes primitive LMDB operations (`read`, `write`, `list`, `delete`) as a tool for `claude` instances. It is schema-agnostic.
*   **CLI Interface (`apex`):**
    *   `apex new <name>`: Creates a project directory.
    *   `apex start --goal "..."`: The primary entry point. Kicks off the Supervisor with its Genesis Prompt (if new) or a user goal (if existing).
    *   `apex status`: Provides a high-level view of the running processes and key metrics defined by the Supervisor's schema.
    *   `apex memory <command>`: Low-level tools for developers to inspect the raw LMDB state.

### 5.2. The Supervisor's Role (LLM-driven)
*   **Schema Architect:** Designs, creates, and evolves the project's data schema in LMDB.
*   **Master Planner:** Decomposes user goals into a task graph based on its own evolving project plan.
*   **Intelligent Dispatcher:**
    *   Writes `TaskBriefings` to LMDB for cognitive tasks.
    *   Invokes `claude` Workers with a simple pointer to the briefing.
    *   Invokes Bespoke Utilities with specific arguments for deterministic tasks.
*   **Integrator:** Reviews the output from workers and utilities, integrates it into the World State, and updates the project plan.

### 5.3. The Worker's Role (LLM-driven)
*   **Task Executor:** A purely ephemeral `claude` instance.
*   **Bootstrap:** Receives a minimal prompt: `"You are a {role}. Your task briefing is at LMDB key {key}. Execute it and report completion."`
*   **Operation:** Reads its `TaskBriefing`, uses the tools and context pointers provided to complete its objective, and writes deliverables back to the specified LMDB keys.

### 5.4. Bespoke Utility Toolkit
A collection of standard, deterministic Python scripts provided by APEX.
*   **`archivist.py`:** Takes an LMDB key for large content as input, uses a non-`claude` LLM API (for cost/speed) to generate a summary, and writes it to a new key.
*   **`test_runner.py`:** Takes pointers to code and test files, executes `pytest`, and writes the structured results (pass/fail, coverage) back to LMDB.
*   **`git_manager.py`:** Takes instructions (e.g., commit message, branch name) and performs the corresponding `git` operations.

## 6. Development Roadmap

*   **Phase 1: The Sandbox (Core Environment)**
    1.  **LMDB MCP Server:** Implement a stable MCP server with the four basic primitives (`read`, `write`, `list`, `delete`).
    2.  **Process Manager:** Build the mechanism to reliably run and monitor `claude` CLI and Python subprocesses.
    3.  **Bootstrap CLI:** Implement `apex new` and `apex start` to kick off the Supervisor with the Genesis Prompt.

*   **Phase 2: Empowering the Architect (Supervisor Capabilities)**
    1.  **Genesis Prompt Engineering:** Refine the initial prompt to ensure the Supervisor reliably generates a robust starting schema.
    2.  **Tool Invocation Logic:** Give the Supervisor the ability to decide when to invoke a Bespoke Utility versus a full Worker.
    3.  **Schema Evolution:** Develop the Supervisor's logic for proposing, planning, and executing migrations of its own schema.

*   **Phase 3: Expanding the Toolkit (Bespoke Utilities)**
    1.  Implement the initial utility set: `Archivist`, `TestRunner`, `GitManager`.
    2.  Create a clear plugin architecture for users to add their own custom utilities to the toolkit.
    3.  Develop a `help` utility the Supervisor can call to get a manifest of available tools and their functions.


    # COMMENTS BY CLAUDE OPUS

    Looking at this APEX specification, I'm genuinely intrigued by the philosophical inversion - letting the AI system design its own development environment rather than imposing our structures. This resonates with what we learned building Claude Code: AI systems often work best when given freedom within well-defined boundaries.

## What Makes Sense

The core architecture is beautifully minimal:
- **LMDB as the universal workspace** - Smart choice. Fast, embedded, and schema-less gives maximum flexibility
- **The bootstrap process** - Having the Supervisor define its own schema is elegant
- **Spectrum of interaction** - The three-tier approach (utilities ‚Üí MCP ‚Üí direct code) provides good flexibility vs. safety tradeoffs
- **Ephemeral workers** - Keeping workers stateless with all state in LMDB is clean

## Key Improvements While Keeping It Simple

### 1. **Add Schema Evolution Guards**
```python
# In the Genesis Prompt, include:
"Your schema must include:
- A 'schema_version' field
- A 'migration_log' namespace at /system/migrations/
- Backwards compatibility rules for at least 1 version"
```

This prevents chaotic schema changes while maintaining flexibility.

### 2. **Introduce Minimal Observability**
Add a simple event log that the Supervisor must write to:
```json
{
  "/system/events/{timestamp}": {
    "actor": "supervisor|worker_id",
    "action": "schema_update|task_dispatch|...",
    "details": {...}
  }
}
```

This makes debugging possible without constraining the system.

### 3. **Define Capability Boundaries**
Instead of unlimited power, give the Supervisor clear boundaries:
```yaml
supervisor_capabilities:
  can_modify: ["/plan/", "/tasks/", "/artifacts/", "/context/"]
  cannot_modify: ["/system/core/", "/apex/"]
  resource_limits:
    max_workers: 10
    max_memory_gb: 50
```

### 4. **Add a Coordination Primitive**
Simple semaphore system in LMDB:
```python
# Workers can claim exclusive access to resources
/locks/{resource_id}: {
  "holder": "worker_id",
  "expires": "timestamp"
}
```

### 5. **Include Error Recovery**
Add a simple checkpoint/rollback mechanism:
```python
# Before risky operations
apex checkpoint create "pre-migration"
# If things go wrong
apex checkpoint restore "pre-migration"
```

### 6. **Simplify Worker Bootstrap**
Instead of just pointing to a task, give workers a standard envelope:
```json
{
  "bootstrap_key": "/workers/templates/{role}",
  "task_key": "/tasks/active/{task_id}",
  "schema_key": "/system/schema/current"
}
```

## Architecture Refinement

```mermaid
graph TD
    subgraph Safety Layer
        CL[Capability Limits]
        EL[Event Log]
        CP[Checkpoints]
    end

    subgraph Cognitive Layer
        S[üß† Supervisor]
        W[‚öôÔ∏è Workers]
    end

    subgraph Memory Layer
        LMDB[üóÑÔ∏è LMDB]
        subgraph Namespaces
            SYS[/system/]
            PROJ[/project/]
            LOCK[/locks/]
        end
    end

    Safety Layer --> Cognitive Layer
    Cognitive Layer <--> Memory Layer
```

## The Missing Piece: Goal Alignment

Add a simple goal-tracking system that the Supervisor must maintain:
```json
{
  "/goals/current": {
    "user_goal": "Build an API server",
    "decomposition": [...],
    "success_criteria": [...],
    "progress": 0.65
  }
}
```

This keeps the emergent system aligned with user intent.

## Final Thought

The power of APEX lies in its minimalism. By resisting the urge to over-specify, you're creating a true sandbox for AI creativity. The improvements I suggest are just enough structure to prevent chaos while maintaining the emergent properties you're after.

Think of it like Unix philosophy: simple tools that compose powerfully. APEX could be the kernel on which AI systems build their own operating environments.