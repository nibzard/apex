└── libraries
    └── liblmdb
        ├── .gitignore
        ├── COPYRIGHT
        ├── Doxyfile
        ├── LICENSE
        ├── Makefile
        ├── intro.doc
        ├── lmdb.h
        ├── mdb.c
        ├── mdb_copy.1
        ├── mdb_copy.c
        ├── mdb_drop.1
        ├── mdb_drop.c
        ├── mdb_dump.1
        ├── mdb_dump.c
        ├── mdb_load.1
        ├── mdb_load.c
        ├── mdb_stat.1
        ├── mdb_stat.c
        ├── midl.c
        ├── midl.h
        ├── mplay.c
        ├── mtest.c
        ├── mtest2.c
        ├── mtest3.c
        ├── mtest4.c
        ├── mtest5.c
        ├── mtest6.c
        ├── sample-bdb.txt
        ├── sample-mdb.txt
        └── tooltag


/libraries/liblmdb/.gitignore:
--------------------------------------------------------------------------------
 1 | mtest
 2 | mtest[23456]
 3 | testdb
 4 | mdb_copy
 5 | mdb_stat
 6 | mdb_dump
 7 | mdb_load
 8 | mdb_drop
 9 | *.lo
10 | *.[ao]
11 | *.so
12 | *.exe
13 | *[~#]
14 | *.bak
15 | *.orig
16 | *.rej
17 | *.gcov
18 | *.gcda
19 | *.gcno
20 | core
21 | core.*
22 | valgrind.*
23 | man/
24 | html/
25 |


--------------------------------------------------------------------------------
/libraries/liblmdb/COPYRIGHT:
--------------------------------------------------------------------------------
 1 | Copyright 2011-2021 Howard Chu, Symas Corp.
 2 | All rights reserved.
 3 |
 4 | Redistribution and use in source and binary forms, with or without
 5 | modification, are permitted only as authorized by the OpenLDAP
 6 | Public License.
 7 |
 8 | A copy of this license is available in the file LICENSE in the
 9 | top-level directory of the distribution or, alternatively, at
10 | <http://www.OpenLDAP.org/license.html>.
11 |
12 | OpenLDAP is a registered trademark of the OpenLDAP Foundation.
13 |
14 | Individual files and/or contributed packages may be copyright by
15 | other parties and/or subject to additional restrictions.
16 |
17 | This work also contains materials derived from public sources.
18 |
19 | Additional information about OpenLDAP can be obtained at
20 | <http://www.openldap.org/>.
21 |


--------------------------------------------------------------------------------
/libraries/liblmdb/Doxyfile:
--------------------------------------------------------------------------------
   1 | # Doxyfile 1.7.1
   2 |
   3 | # This file describes the settings to be used by the documentation system
   4 | # doxygen (www.doxygen.org) for a project
   5 | #
   6 | # All text after a hash (#) is considered a comment and will be ignored
   7 | # The format is:
   8 | #       TAG = value [value, ...]
   9 | # For lists items can also be appended using:
  10 | #       TAG += value [value, ...]
  11 | # Values that contain spaces should be placed between quotes (" ")
  12 |
  13 | #---------------------------------------------------------------------------
  14 | # Project related configuration options
  15 | #---------------------------------------------------------------------------
  16 |
  17 | # This tag specifies the encoding used for all characters in the config file
  18 | # that follow. The default is UTF-8 which is also the encoding used for all
  19 | # text before the first occurrence of this tag. Doxygen uses libiconv (or the
  20 | # iconv built into libc) for the transcoding. See
  21 | # http://www.gnu.org/software/libiconv for the list of possible encodings.
  22 |
  23 | DOXYFILE_ENCODING      = UTF-8
  24 |
  25 | # The PROJECT_NAME tag is a single word (or a sequence of words surrounded
  26 | # by quotes) that should identify the project.
  27 |
  28 | PROJECT_NAME           = LMDB
  29 |
  30 | # The PROJECT_NUMBER tag can be used to enter a project or revision number.
  31 | # This could be handy for archiving the generated documentation or
  32 | # if some version control system is used.
  33 |
  34 | PROJECT_NUMBER         =
  35 |
  36 | # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
  37 | # base path where the generated documentation will be put.
  38 | # If a relative path is entered, it will be relative to the location
  39 | # where doxygen was started. If left blank the current directory will be used.
  40 |
  41 | OUTPUT_DIRECTORY       =
  42 |
  43 | # If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
  44 | # 4096 sub-directories (in 2 levels) under the output directory of each output
  45 | # format and will distribute the generated files over these directories.
  46 | # Enabling this option can be useful when feeding doxygen a huge amount of
  47 | # source files, where putting all generated files in the same directory would
  48 | # otherwise cause performance problems for the file system.
  49 |
  50 | CREATE_SUBDIRS         = NO
  51 |
  52 | # The OUTPUT_LANGUAGE tag is used to specify the language in which all
  53 | # documentation generated by doxygen is written. Doxygen will use this
  54 | # information to generate all constant output in the proper language.
  55 | # The default language is English, other supported languages are:
  56 | # Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
  57 | # Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,
  58 | # Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
  59 | # messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
  60 | # Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak,
  61 | # Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
  62 |
  63 | OUTPUT_LANGUAGE        = English
  64 |
  65 | # If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
  66 | # include brief member descriptions after the members that are listed in
  67 | # the file and class documentation (similar to JavaDoc).
  68 | # Set to NO to disable this.
  69 |
  70 | BRIEF_MEMBER_DESC      = YES
  71 |
  72 | # If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
  73 | # the brief description of a member or function before the detailed description.
  74 | # Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
  75 | # brief descriptions will be completely suppressed.
  76 |
  77 | REPEAT_BRIEF           = YES
  78 |
  79 | # This tag implements a quasi-intelligent brief description abbreviator
  80 | # that is used to form the text in various listings. Each string
  81 | # in this list, if found as the leading text of the brief description, will be
  82 | # stripped from the text and the result after processing the whole list, is
  83 | # used as the annotated text. Otherwise, the brief description is used as-is.
  84 | # If left blank, the following values are used ("$name" is automatically
  85 | # replaced with the name of the entity): "The $name class" "The $name widget"
  86 | # "The $name file" "is" "provides" "specifies" "contains"
  87 | # "represents" "a" "an" "the"
  88 |
  89 | ABBREVIATE_BRIEF       =
  90 |
  91 | # If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
  92 | # Doxygen will generate a detailed section even if there is only a brief
  93 | # description.
  94 |
  95 | ALWAYS_DETAILED_SEC    = NO
  96 |
  97 | # If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
  98 | # inherited members of a class in the documentation of that class as if those
  99 | # members were ordinary class members. Constructors, destructors and assignment
 100 | # operators of the base classes will not be shown.
 101 |
 102 | INLINE_INHERITED_MEMB  = NO
 103 |
 104 | # If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
 105 | # path before files name in the file list and in the header files. If set
 106 | # to NO the shortest path that makes the file name unique will be used.
 107 |
 108 | FULL_PATH_NAMES        = YES
 109 |
 110 | # If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
 111 | # can be used to strip a user-defined part of the path. Stripping is
 112 | # only done if one of the specified strings matches the left-hand part of
 113 | # the path. The tag can be used to show relative paths in the file list.
 114 | # If left blank the directory from which doxygen is run is used as the
 115 | # path to strip.
 116 |
 117 | STRIP_FROM_PATH        =
 118 |
 119 | # The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
 120 | # the path mentioned in the documentation of a class, which tells
 121 | # the reader which header file to include in order to use a class.
 122 | # If left blank only the name of the header file containing the class
 123 | # definition is used. Otherwise one should specify the include paths that
 124 | # are normally passed to the compiler using the -I flag.
 125 |
 126 | STRIP_FROM_INC_PATH    =
 127 |
 128 | # If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
 129 | # (but less readable) file names. This can be useful is your file systems
 130 | # doesn't support long names like on DOS, Mac, or CD-ROM.
 131 |
 132 | SHORT_NAMES            = NO
 133 |
 134 | # If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
 135 | # will interpret the first line (until the first dot) of a JavaDoc-style
 136 | # comment as the brief description. If set to NO, the JavaDoc
 137 | # comments will behave just like regular Qt-style comments
 138 | # (thus requiring an explicit @brief command for a brief description.)
 139 |
 140 | JAVADOC_AUTOBRIEF      = NO
 141 |
 142 | # If the QT_AUTOBRIEF tag is set to YES then Doxygen will
 143 | # interpret the first line (until the first dot) of a Qt-style
 144 | # comment as the brief description. If set to NO, the comments
 145 | # will behave just like regular Qt-style comments (thus requiring
 146 | # an explicit \brief command for a brief description.)
 147 |
 148 | QT_AUTOBRIEF           = NO
 149 |
 150 | # The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
 151 | # treat a multi-line C++ special comment block (i.e. a block of //! or ///
 152 | # comments) as a brief description. This used to be the default behaviour.
 153 | # The new default is to treat a multi-line C++ comment block as a detailed
 154 | # description. Set this tag to YES if you prefer the old behaviour instead.
 155 |
 156 | MULTILINE_CPP_IS_BRIEF = NO
 157 |
 158 | # If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
 159 | # member inherits the documentation from any documented member that it
 160 | # re-implements.
 161 |
 162 | INHERIT_DOCS           = YES
 163 |
 164 | # If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
 165 | # a new page for each member. If set to NO, the documentation of a member will
 166 | # be part of the file/class/namespace that contains it.
 167 |
 168 | SEPARATE_MEMBER_PAGES  = NO
 169 |
 170 | # The TAB_SIZE tag can be used to set the number of spaces in a tab.
 171 | # Doxygen uses this value to replace tabs by spaces in code fragments.
 172 |
 173 | TAB_SIZE               = 4
 174 |
 175 | # This tag can be used to specify a number of aliases that acts
 176 | # as commands in the documentation. An alias has the form "name=value".
 177 | # For example adding "sideeffect=\par Side Effects:\n" will allow you to
 178 | # put the command \sideeffect (or @sideeffect) in the documentation, which
 179 | # will result in a user-defined paragraph with heading "Side Effects:".
 180 | # You can put \n's in the value part of an alias to insert newlines.
 181 |
 182 | ALIASES                =
 183 |
 184 | # Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
 185 | # sources only. Doxygen will then generate output that is more tailored for C.
 186 | # For instance, some of the names that are used will be different. The list
 187 | # of all members will be omitted, etc.
 188 |
 189 | OPTIMIZE_OUTPUT_FOR_C  = YES
 190 |
 191 | # Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
 192 | # sources only. Doxygen will then generate output that is more tailored for
 193 | # Java. For instance, namespaces will be presented as packages, qualified
 194 | # scopes will look different, etc.
 195 |
 196 | OPTIMIZE_OUTPUT_JAVA   = NO
 197 |
 198 | # Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
 199 | # sources only. Doxygen will then generate output that is more tailored for
 200 | # Fortran.
 201 |
 202 | OPTIMIZE_FOR_FORTRAN   = NO
 203 |
 204 | # Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
 205 | # sources. Doxygen will then generate output that is tailored for
 206 | # VHDL.
 207 |
 208 | OPTIMIZE_OUTPUT_VHDL   = NO
 209 |
 210 | # Doxygen selects the parser to use depending on the extension of the files it
 211 | # parses. With this tag you can assign which parser to use for a given extension.
 212 | # Doxygen has a built-in mapping, but you can override or extend it using this
 213 | # tag. The format is ext=language, where ext is a file extension, and language
 214 | # is one of the parsers supported by doxygen: IDL, Java, Javascript, CSharp, C,
 215 | # C++, D, PHP, Objective-C, Python, Fortran, VHDL, C, C++. For instance to make
 216 | # doxygen treat .inc files as Fortran files (default is PHP), and .f files as C
 217 | # (default is Fortran), use: inc=Fortran f=C. Note that for custom extensions
 218 | # you also need to set FILE_PATTERNS otherwise the files are not read by doxygen.
 219 |
 220 | EXTENSION_MAPPING      =
 221 |
 222 | # If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
 223 | # to include (a tag file for) the STL sources as input, then you should
 224 | # set this tag to YES in order to let doxygen match functions declarations and
 225 | # definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
 226 | # func(std::string) {}). This also make the inheritance and collaboration
 227 | # diagrams that involve STL classes more complete and accurate.
 228 |
 229 | BUILTIN_STL_SUPPORT    = NO
 230 |
 231 | # If you use Microsoft's C++/CLI language, you should set this option to YES to
 232 | # enable parsing support.
 233 |
 234 | CPP_CLI_SUPPORT        = NO
 235 |
 236 | # Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
 237 | # Doxygen will parse them like normal C++ but will assume all classes use public
 238 | # instead of private inheritance when no explicit protection keyword is present.
 239 |
 240 | SIP_SUPPORT            = NO
 241 |
 242 | # For Microsoft's IDL there are propget and propput attributes to indicate getter
 243 | # and setter methods for a property. Setting this option to YES (the default)
 244 | # will make doxygen to replace the get and set methods by a property in the
 245 | # documentation. This will only work if the methods are indeed getting or
 246 | # setting a simple type. If this is not the case, or you want to show the
 247 | # methods anyway, you should set this option to NO.
 248 |
 249 | IDL_PROPERTY_SUPPORT   = YES
 250 |
 251 | # If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
 252 | # tag is set to YES, then doxygen will reuse the documentation of the first
 253 | # member in the group (if any) for the other members of the group. By default
 254 | # all members of a group must be documented explicitly.
 255 |
 256 | DISTRIBUTE_GROUP_DOC   = YES
 257 |
 258 | # Set the SUBGROUPING tag to YES (the default) to allow class member groups of
 259 | # the same type (for instance a group of public functions) to be put as a
 260 | # subgroup of that type (e.g. under the Public Functions section). Set it to
 261 | # NO to prevent subgrouping. Alternatively, this can be done per class using
 262 | # the \nosubgrouping command.
 263 |
 264 | SUBGROUPING            = YES
 265 |
 266 | INLINE_GROUPED_CLASSES = YES
 267 | # When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
 268 | # is documented as struct, union, or enum with the name of the typedef. So
 269 | # typedef struct TypeS {} TypeT, will appear in the documentation as a struct
 270 | # with name TypeT. When disabled the typedef will appear as a member of a file,
 271 | # namespace, or class. And the struct will be named TypeS. This can typically
 272 | # be useful for C code in case the coding convention dictates that all compound
 273 | # types are typedef'ed and only the typedef is referenced, never the tag name.
 274 |
 275 | TYPEDEF_HIDES_STRUCT   = YES
 276 |
 277 | # The SYMBOL_CACHE_SIZE determines the size of the internal cache use to
 278 | # determine which symbols to keep in memory and which to flush to disk.
 279 | # When the cache is full, less often used symbols will be written to disk.
 280 | # For small to medium size projects (<1000 input files) the default value is
 281 | # probably good enough. For larger projects a too small cache size can cause
 282 | # doxygen to be busy swapping symbols to and from disk most of the time
 283 | # causing a significant performance penality.
 284 | # If the system has enough physical memory increasing the cache will improve the
 285 | # performance by keeping more symbols in memory. Note that the value works on
 286 | # a logarithmic scale so increasing the size by one will rougly double the
 287 | # memory usage. The cache size is given by this formula:
 288 | # 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
 289 | # corresponding to a cache size of 2^16 = 65536 symbols
 290 |
 291 | SYMBOL_CACHE_SIZE      = 0
 292 |
 293 | #---------------------------------------------------------------------------
 294 | # Build related configuration options
 295 | #---------------------------------------------------------------------------
 296 |
 297 | # If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
 298 | # documentation are documented, even if no documentation was available.
 299 | # Private class members and static file members will be hidden unless
 300 | # the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
 301 |
 302 | EXTRACT_ALL            = NO
 303 |
 304 | # If the EXTRACT_PRIVATE tag is set to YES all private members of a class
 305 | # will be included in the documentation.
 306 |
 307 | EXTRACT_PRIVATE        = NO
 308 |
 309 | # If the EXTRACT_STATIC tag is set to YES all static members of a file
 310 | # will be included in the documentation.
 311 |
 312 | EXTRACT_STATIC         = YES
 313 |
 314 | # If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
 315 | # defined locally in source files will be included in the documentation.
 316 | # If set to NO only classes defined in header files are included.
 317 |
 318 | EXTRACT_LOCAL_CLASSES  = YES
 319 |
 320 | # This flag is only useful for Objective-C code. When set to YES local
 321 | # methods, which are defined in the implementation section but not in
 322 | # the interface are included in the documentation.
 323 | # If set to NO (the default) only methods in the interface are included.
 324 |
 325 | EXTRACT_LOCAL_METHODS  = NO
 326 |
 327 | # If this flag is set to YES, the members of anonymous namespaces will be
 328 | # extracted and appear in the documentation as a namespace called
 329 | # 'anonymous_namespace{file}', where file will be replaced with the base
 330 | # name of the file that contains the anonymous namespace. By default
 331 | # anonymous namespace are hidden.
 332 |
 333 | EXTRACT_ANON_NSPACES   = NO
 334 |
 335 | # If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
 336 | # undocumented members of documented classes, files or namespaces.
 337 | # If set to NO (the default) these members will be included in the
 338 | # various overviews, but no documentation section is generated.
 339 | # This option has no effect if EXTRACT_ALL is enabled.
 340 |
 341 | HIDE_UNDOC_MEMBERS     = NO
 342 |
 343 | # If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
 344 | # undocumented classes that are normally visible in the class hierarchy.
 345 | # If set to NO (the default) these classes will be included in the various
 346 | # overviews. This option has no effect if EXTRACT_ALL is enabled.
 347 |
 348 | HIDE_UNDOC_CLASSES     = NO
 349 |
 350 | # If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
 351 | # friend (class|struct|union) declarations.
 352 | # If set to NO (the default) these declarations will be included in the
 353 | # documentation.
 354 |
 355 | HIDE_FRIEND_COMPOUNDS  = NO
 356 |
 357 | # If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
 358 | # documentation blocks found inside the body of a function.
 359 | # If set to NO (the default) these blocks will be appended to the
 360 | # function's detailed documentation block.
 361 |
 362 | HIDE_IN_BODY_DOCS      = NO
 363 |
 364 | # The INTERNAL_DOCS tag determines if documentation
 365 | # that is typed after a \internal command is included. If the tag is set
 366 | # to NO (the default) then the documentation will be excluded.
 367 | # Set it to YES to include the internal documentation.
 368 |
 369 | INTERNAL_DOCS          = NO
 370 |
 371 | # If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
 372 | # file names in lower-case letters. If set to YES upper-case letters are also
 373 | # allowed. This is useful if you have classes or files whose names only differ
 374 | # in case and if your file system supports case sensitive file names. Windows
 375 | # and Mac users are advised to set this option to NO.
 376 |
 377 | CASE_SENSE_NAMES       = YES
 378 |
 379 | # If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
 380 | # will show members with their full class and namespace scopes in the
 381 | # documentation. If set to YES the scope will be hidden.
 382 |
 383 | HIDE_SCOPE_NAMES       = NO
 384 |
 385 | # If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
 386 | # will put a list of the files that are included by a file in the documentation
 387 | # of that file.
 388 |
 389 | SHOW_INCLUDE_FILES     = YES
 390 |
 391 | # If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen
 392 | # will list include files with double quotes in the documentation
 393 | # rather than with sharp brackets.
 394 |
 395 | FORCE_LOCAL_INCLUDES   = NO
 396 |
 397 | # If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
 398 | # is inserted in the documentation for inline members.
 399 |
 400 | INLINE_INFO            = YES
 401 |
 402 | # If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
 403 | # will sort the (detailed) documentation of file and class members
 404 | # alphabetically by member name. If set to NO the members will appear in
 405 | # declaration order.
 406 |
 407 | SORT_MEMBER_DOCS       = NO
 408 |
 409 | # If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
 410 | # brief documentation of file, namespace and class members alphabetically
 411 | # by member name. If set to NO (the default) the members will appear in
 412 | # declaration order.
 413 |
 414 | SORT_BRIEF_DOCS        = NO
 415 |
 416 | # If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen
 417 | # will sort the (brief and detailed) documentation of class members so that
 418 | # constructors and destructors are listed first. If set to NO (the default)
 419 | # the constructors will appear in the respective orders defined by
 420 | # SORT_MEMBER_DOCS and SORT_BRIEF_DOCS.
 421 | # This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO
 422 | # and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.
 423 |
 424 | SORT_MEMBERS_CTORS_1ST = NO
 425 |
 426 | # If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
 427 | # hierarchy of group names into alphabetical order. If set to NO (the default)
 428 | # the group names will appear in their defined order.
 429 |
 430 | SORT_GROUP_NAMES       = NO
 431 |
 432 | # If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
 433 | # sorted by fully-qualified names, including namespaces. If set to
 434 | # NO (the default), the class list will be sorted only by class name,
 435 | # not including the namespace part.
 436 | # Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
 437 | # Note: This option applies only to the class list, not to the
 438 | # alphabetical list.
 439 |
 440 | SORT_BY_SCOPE_NAME     = NO
 441 |
 442 | # The GENERATE_TODOLIST tag can be used to enable (YES) or
 443 | # disable (NO) the todo list. This list is created by putting \todo
 444 | # commands in the documentation.
 445 |
 446 | GENERATE_TODOLIST      = YES
 447 |
 448 | # The GENERATE_TESTLIST tag can be used to enable (YES) or
 449 | # disable (NO) the test list. This list is created by putting \test
 450 | # commands in the documentation.
 451 |
 452 | GENERATE_TESTLIST      = YES
 453 |
 454 | # The GENERATE_BUGLIST tag can be used to enable (YES) or
 455 | # disable (NO) the bug list. This list is created by putting \bug
 456 | # commands in the documentation.
 457 |
 458 | GENERATE_BUGLIST       = YES
 459 |
 460 | # The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
 461 | # disable (NO) the deprecated list. This list is created by putting
 462 | # \deprecated commands in the documentation.
 463 |
 464 | GENERATE_DEPRECATEDLIST= YES
 465 |
 466 | # The ENABLED_SECTIONS tag can be used to enable conditional
 467 | # documentation sections, marked by \if sectionname ... \endif.
 468 |
 469 | ENABLED_SECTIONS       =
 470 |
 471 | # The MAX_INITIALIZER_LINES tag determines the maximum number of lines
 472 | # the initial value of a variable or define consists of for it to appear in
 473 | # the documentation. If the initializer consists of more lines than specified
 474 | # here it will be hidden. Use a value of 0 to hide initializers completely.
 475 | # The appearance of the initializer of individual variables and defines in the
 476 | # documentation can be controlled using \showinitializer or \hideinitializer
 477 | # command in the documentation regardless of this setting.
 478 |
 479 | MAX_INITIALIZER_LINES  = 30
 480 |
 481 | # Set the SHOW_USED_FILES tag to NO to disable the list of files generated
 482 | # at the bottom of the documentation of classes and structs. If set to YES the
 483 | # list will mention the files that were used to generate the documentation.
 484 |
 485 | SHOW_USED_FILES        = YES
 486 |
 487 | # If the sources in your project are distributed over multiple directories
 488 | # then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy
 489 | # in the documentation. The default is NO.
 490 |
 491 | SHOW_DIRECTORIES       = NO
 492 |
 493 | # Set the SHOW_FILES tag to NO to disable the generation of the Files page.
 494 | # This will remove the Files entry from the Quick Index and from the
 495 | # Folder Tree View (if specified). The default is YES.
 496 |
 497 | SHOW_FILES             = YES
 498 |
 499 | # Set the SHOW_NAMESPACES tag to NO to disable the generation of the
 500 | # Namespaces page.
 501 | # This will remove the Namespaces entry from the Quick Index
 502 | # and from the Folder Tree View (if specified). The default is YES.
 503 |
 504 | SHOW_NAMESPACES        = YES
 505 |
 506 | # The FILE_VERSION_FILTER tag can be used to specify a program or script that
 507 | # doxygen should invoke to get the current version for each file (typically from
 508 | # the version control system). Doxygen will invoke the program by executing (via
 509 | # popen()) the command <command> <input-file>, where <command> is the value of
 510 | # the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
 511 | # provided by doxygen. Whatever the program writes to standard output
 512 | # is used as the file version. See the manual for examples.
 513 |
 514 | FILE_VERSION_FILTER    =
 515 |
 516 | # The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
 517 | # by doxygen. The layout file controls the global structure of the generated
 518 | # output files in an output format independent way. The create the layout file
 519 | # that represents doxygen's defaults, run doxygen with the -l option.
 520 | # You can optionally specify a file name after the option, if omitted
 521 | # DoxygenLayout.xml will be used as the name of the layout file.
 522 |
 523 | LAYOUT_FILE            =
 524 |
 525 | #---------------------------------------------------------------------------
 526 | # configuration options related to warning and progress messages
 527 | #---------------------------------------------------------------------------
 528 |
 529 | # The QUIET tag can be used to turn on/off the messages that are generated
 530 | # by doxygen. Possible values are YES and NO. If left blank NO is used.
 531 |
 532 | QUIET                  = NO
 533 |
 534 | # The WARNINGS tag can be used to turn on/off the warning messages that are
 535 | # generated by doxygen. Possible values are YES and NO. If left blank
 536 | # NO is used.
 537 |
 538 | WARNINGS               = YES
 539 |
 540 | # If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
 541 | # for undocumented members. If EXTRACT_ALL is set to YES then this flag will
 542 | # automatically be disabled.
 543 |
 544 | WARN_IF_UNDOCUMENTED   = YES
 545 |
 546 | # If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
 547 | # potential errors in the documentation, such as not documenting some
 548 | # parameters in a documented function, or documenting parameters that
 549 | # don't exist or using markup commands wrongly.
 550 |
 551 | WARN_IF_DOC_ERROR      = YES
 552 |
 553 | # This WARN_NO_PARAMDOC option can be abled to get warnings for
 554 | # functions that are documented, but have no documentation for their parameters
 555 | # or return value. If set to NO (the default) doxygen will only warn about
 556 | # wrong or incomplete parameter documentation, but not about the absence of
 557 | # documentation.
 558 |
 559 | WARN_NO_PARAMDOC       = NO
 560 |
 561 | # The WARN_FORMAT tag determines the format of the warning messages that
 562 | # doxygen can produce. The string should contain the $file, $line, and $text
 563 | # tags, which will be replaced by the file and line number from which the
 564 | # warning originated and the warning text. Optionally the format may contain
 565 | # $version, which will be replaced by the version of the file (if it could
 566 | # be obtained via FILE_VERSION_FILTER)
 567 |
 568 | WARN_FORMAT            = "$file:$line: $text"
 569 |
 570 | # The WARN_LOGFILE tag can be used to specify a file to which warning
 571 | # and error messages should be written. If left blank the output is written
 572 | # to stderr.
 573 |
 574 | WARN_LOGFILE           =
 575 |
 576 | #---------------------------------------------------------------------------
 577 | # configuration options related to the input files
 578 | #---------------------------------------------------------------------------
 579 |
 580 | # The INPUT tag can be used to specify the files and/or directories that contain
 581 | # documented source files. You may enter file names like "myfile.cpp" or
 582 | # directories like "/usr/src/myproject". Separate the files or directories
 583 | # with spaces.
 584 |
 585 | INPUT                  = lmdb.h midl.h mdb.c midl.c intro.doc
 586 |
 587 | # This tag can be used to specify the character encoding of the source files
 588 | # that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
 589 | # also the default input encoding. Doxygen uses libiconv (or the iconv built
 590 | # into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
 591 | # the list of possible encodings.
 592 |
 593 | INPUT_ENCODING         = UTF-8
 594 |
 595 | # If the value of the INPUT tag contains directories, you can use the
 596 | # FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
 597 | # and *.h) to filter out the source-files in the directories. If left
 598 | # blank the following patterns are tested:
 599 | # *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx
 600 | # *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
 601 |
 602 | FILE_PATTERNS          =
 603 |
 604 | # The RECURSIVE tag can be used to turn specify whether or not subdirectories
 605 | # should be searched for input files as well. Possible values are YES and NO.
 606 | # If left blank NO is used.
 607 |
 608 | RECURSIVE              = NO
 609 |
 610 | # The EXCLUDE tag can be used to specify files and/or directories that should
 611 | # excluded from the INPUT source files. This way you can easily exclude a
 612 | # subdirectory from a directory tree whose root is specified with the INPUT tag.
 613 |
 614 | EXCLUDE                =
 615 |
 616 | # The EXCLUDE_SYMLINKS tag can be used select whether or not files or
 617 | # directories that are symbolic links (a Unix filesystem feature) are excluded
 618 | # from the input.
 619 |
 620 | EXCLUDE_SYMLINKS       = NO
 621 |
 622 | # If the value of the INPUT tag contains directories, you can use the
 623 | # EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
 624 | # certain files from those directories. Note that the wildcards are matched
 625 | # against the file with absolute path, so to exclude all test directories
 626 | # for example use the pattern */test/*
 627 |
 628 | EXCLUDE_PATTERNS       =
 629 |
 630 | # The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
 631 | # (namespaces, classes, functions, etc.) that should be excluded from the
 632 | # output. The symbol name can be a fully qualified name, a word, or if the
 633 | # wildcard * is used, a substring. Examples: ANamespace, AClass,
 634 | # AClass::ANamespace, ANamespace::*Test
 635 |
 636 | EXCLUDE_SYMBOLS        =
 637 |
 638 | # The EXAMPLE_PATH tag can be used to specify one or more files or
 639 | # directories that contain example code fragments that are included (see
 640 | # the \include command).
 641 |
 642 | EXAMPLE_PATH           =
 643 |
 644 | # If the value of the EXAMPLE_PATH tag contains directories, you can use the
 645 | # EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
 646 | # and *.h) to filter out the source-files in the directories. If left
 647 | # blank all files are included.
 648 |
 649 | EXAMPLE_PATTERNS       =
 650 |
 651 | # If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
 652 | # searched for input files to be used with the \include or \dontinclude
 653 | # commands irrespective of the value of the RECURSIVE tag.
 654 | # Possible values are YES and NO. If left blank NO is used.
 655 |
 656 | EXAMPLE_RECURSIVE      = NO
 657 |
 658 | # The IMAGE_PATH tag can be used to specify one or more files or
 659 | # directories that contain image that are included in the documentation (see
 660 | # the \image command).
 661 |
 662 | IMAGE_PATH             =
 663 |
 664 | # The INPUT_FILTER tag can be used to specify a program that doxygen should
 665 | # invoke to filter for each input file. Doxygen will invoke the filter program
 666 | # by executing (via popen()) the command <filter> <input-file>, where <filter>
 667 | # is the value of the INPUT_FILTER tag, and <input-file> is the name of an
 668 | # input file. Doxygen will then use the output that the filter program writes
 669 | # to standard output.
 670 | # If FILTER_PATTERNS is specified, this tag will be
 671 | # ignored.
 672 |
 673 | INPUT_FILTER           =
 674 |
 675 | # The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
 676 | # basis.
 677 | # Doxygen will compare the file name with each pattern and apply the
 678 | # filter if there is a match.
 679 | # The filters are a list of the form:
 680 | # pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
 681 | # info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER
 682 | # is applied to all files.
 683 |
 684 | FILTER_PATTERNS        =
 685 |
 686 | # If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
 687 | # INPUT_FILTER) will be used to filter the input files when producing source
 688 | # files to browse (i.e. when SOURCE_BROWSER is set to YES).
 689 |
 690 | FILTER_SOURCE_FILES    = NO
 691 |
 692 | #---------------------------------------------------------------------------
 693 | # configuration options related to source browsing
 694 | #---------------------------------------------------------------------------
 695 |
 696 | # If the SOURCE_BROWSER tag is set to YES then a list of source files will
 697 | # be generated. Documented entities will be cross-referenced with these sources.
 698 | # Note: To get rid of all source code in the generated output, make sure also
 699 | # VERBATIM_HEADERS is set to NO.
 700 |
 701 | SOURCE_BROWSER         = NO
 702 |
 703 | # Setting the INLINE_SOURCES tag to YES will include the body
 704 | # of functions and classes directly in the documentation.
 705 |
 706 | INLINE_SOURCES         = NO
 707 |
 708 | # Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
 709 | # doxygen to hide any special comment blocks from generated source code
 710 | # fragments. Normal C and C++ comments will always remain visible.
 711 |
 712 | STRIP_CODE_COMMENTS    = YES
 713 |
 714 | # If the REFERENCED_BY_RELATION tag is set to YES
 715 | # then for each documented function all documented
 716 | # functions referencing it will be listed.
 717 |
 718 | REFERENCED_BY_RELATION = NO
 719 |
 720 | # If the REFERENCES_RELATION tag is set to YES
 721 | # then for each documented function all documented entities
 722 | # called/used by that function will be listed.
 723 |
 724 | REFERENCES_RELATION    = NO
 725 |
 726 | # If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
 727 | # and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
 728 | # functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
 729 | # link to the source code.
 730 | # Otherwise they will link to the documentation.
 731 |
 732 | REFERENCES_LINK_SOURCE = YES
 733 |
 734 | # If the USE_HTAGS tag is set to YES then the references to source code
 735 | # will point to the HTML generated by the htags(1) tool instead of doxygen
 736 | # built-in source browser. The htags tool is part of GNU's global source
 737 | # tagging system (see http://www.gnu.org/software/global/global.html). You
 738 | # will need version 4.8.6 or higher.
 739 |
 740 | USE_HTAGS              = NO
 741 |
 742 | # If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
 743 | # will generate a verbatim copy of the header file for each class for
 744 | # which an include is specified. Set to NO to disable this.
 745 |
 746 | VERBATIM_HEADERS       = YES
 747 |
 748 | #---------------------------------------------------------------------------
 749 | # configuration options related to the alphabetical class index
 750 | #---------------------------------------------------------------------------
 751 |
 752 | # If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
 753 | # of all compounds will be generated. Enable this if the project
 754 | # contains a lot of classes, structs, unions or interfaces.
 755 |
 756 | ALPHABETICAL_INDEX     = YES
 757 |
 758 | # If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
 759 | # the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
 760 | # in which this list will be split (can be a number in the range [1..20])
 761 |
 762 | COLS_IN_ALPHA_INDEX    = 5
 763 |
 764 | # In case all classes in a project start with a common prefix, all
 765 | # classes will be put under the same header in the alphabetical index.
 766 | # The IGNORE_PREFIX tag can be used to specify one or more prefixes that
 767 | # should be ignored while generating the index headers.
 768 |
 769 | IGNORE_PREFIX          =
 770 |
 771 | #---------------------------------------------------------------------------
 772 | # configuration options related to the HTML output
 773 | #---------------------------------------------------------------------------
 774 |
 775 | # If the GENERATE_HTML tag is set to YES (the default) Doxygen will
 776 | # generate HTML output.
 777 |
 778 | GENERATE_HTML          = YES
 779 |
 780 | # The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
 781 | # If a relative path is entered the value of OUTPUT_DIRECTORY will be
 782 | # put in front of it. If left blank `html' will be used as the default path.
 783 |
 784 | HTML_OUTPUT            = html
 785 |
 786 | # The HTML_FILE_EXTENSION tag can be used to specify the file extension for
 787 | # each generated HTML page (for example: .htm,.php,.asp). If it is left blank
 788 | # doxygen will generate files with .html extension.
 789 |
 790 | HTML_FILE_EXTENSION    = .html
 791 |
 792 | # The HTML_HEADER tag can be used to specify a personal HTML header for
 793 | # each generated HTML page. If it is left blank doxygen will generate a
 794 | # standard header.
 795 |
 796 | HTML_HEADER            =
 797 |
 798 | # The HTML_FOOTER tag can be used to specify a personal HTML footer for
 799 | # each generated HTML page. If it is left blank doxygen will generate a
 800 | # standard footer.
 801 |
 802 | HTML_FOOTER            =
 803 |
 804 | # The HTML_STYLESHEET tag can be used to specify a user-defined cascading
 805 | # style sheet that is used by each HTML page. It can be used to
 806 | # fine-tune the look of the HTML output. If the tag is left blank doxygen
 807 | # will generate a default style sheet. Note that doxygen will try to copy
 808 | # the style sheet file to the HTML output directory, so don't put your own
 809 | # stylesheet in the HTML output directory as well, or it will be erased!
 810 |
 811 | HTML_STYLESHEET        =
 812 |
 813 | # The HTML_COLORSTYLE_HUE tag controls the color of the HTML output.
 814 | # Doxygen will adjust the colors in the stylesheet and background images
 815 | # according to this color. Hue is specified as an angle on a colorwheel,
 816 | # see http://en.wikipedia.org/wiki/Hue for more information.
 817 | # For instance the value 0 represents red, 60 is yellow, 120 is green,
 818 | # 180 is cyan, 240 is blue, 300 purple, and 360 is red again.
 819 | # The allowed range is 0 to 359.
 820 |
 821 | HTML_COLORSTYLE_HUE    = 220
 822 |
 823 | # The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of
 824 | # the colors in the HTML output. For a value of 0 the output will use
 825 | # grayscales only. A value of 255 will produce the most vivid colors.
 826 |
 827 | HTML_COLORSTYLE_SAT    = 100
 828 |
 829 | # The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to
 830 | # the luminance component of the colors in the HTML output. Values below
 831 | # 100 gradually make the output lighter, whereas values above 100 make
 832 | # the output darker. The value divided by 100 is the actual gamma applied,
 833 | # so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2,
 834 | # and 100 does not change the gamma.
 835 |
 836 | HTML_COLORSTYLE_GAMMA  = 80
 837 |
 838 | # If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
 839 | # page will contain the date and time when the page was generated. Setting
 840 | # this to NO can help when comparing the output of multiple runs.
 841 |
 842 | HTML_TIMESTAMP         = YES
 843 |
 844 | # If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,
 845 | # files or namespaces will be aligned in HTML using tables. If set to
 846 | # NO a bullet list will be used.
 847 |
 848 | HTML_ALIGN_MEMBERS     = YES
 849 |
 850 | # If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
 851 | # documentation will contain sections that can be hidden and shown after the
 852 | # page has loaded. For this to work a browser that supports
 853 | # JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox
 854 | # Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
 855 |
 856 | HTML_DYNAMIC_SECTIONS  = NO
 857 |
 858 | # If the GENERATE_DOCSET tag is set to YES, additional index files
 859 | # will be generated that can be used as input for Apple's Xcode 3
 860 | # integrated development environment, introduced with OSX 10.5 (Leopard).
 861 | # To create a documentation set, doxygen will generate a Makefile in the
 862 | # HTML output directory. Running make will produce the docset in that
 863 | # directory and running "make install" will install the docset in
 864 | # ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
 865 | # it at startup.
 866 | # See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
 867 | # for more information.
 868 |
 869 | GENERATE_DOCSET        = NO
 870 |
 871 | # When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
 872 | # feed. A documentation feed provides an umbrella under which multiple
 873 | # documentation sets from a single provider (such as a company or product suite)
 874 | # can be grouped.
 875 |
 876 | DOCSET_FEEDNAME        = "Doxygen generated docs"
 877 |
 878 | # When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
 879 | # should uniquely identify the documentation set bundle. This should be a
 880 | # reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
 881 | # will append .docset to the name.
 882 |
 883 | DOCSET_BUNDLE_ID       = org.doxygen.Project
 884 |
 885 | # When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely identify
 886 | # the documentation publisher. This should be a reverse domain-name style
 887 | # string, e.g. com.mycompany.MyDocSet.documentation.
 888 |
 889 | DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
 890 |
 891 | # The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.
 892 |
 893 | DOCSET_PUBLISHER_NAME  = Publisher
 894 |
 895 | # If the GENERATE_HTMLHELP tag is set to YES, additional index files
 896 | # will be generated that can be used as input for tools like the
 897 | # Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
 898 | # of the generated HTML documentation.
 899 |
 900 | GENERATE_HTMLHELP      = NO
 901 |
 902 | # If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
 903 | # be used to specify the file name of the resulting .chm file. You
 904 | # can add a path in front of the file if the result should not be
 905 | # written to the html output directory.
 906 |
 907 | CHM_FILE               =
 908 |
 909 | # If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
 910 | # be used to specify the location (absolute path including file name) of
 911 | # the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
 912 | # the HTML help compiler on the generated index.hhp.
 913 |
 914 | HHC_LOCATION           =
 915 |
 916 | # If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
 917 | # controls if a separate .chi index file is generated (YES) or that
 918 | # it should be included in the master .chm file (NO).
 919 |
 920 | GENERATE_CHI           = NO
 921 |
 922 | # If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
 923 | # is used to encode HtmlHelp index (hhk), content (hhc) and project file
 924 | # content.
 925 |
 926 | CHM_INDEX_ENCODING     =
 927 |
 928 | # If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
 929 | # controls whether a binary table of contents is generated (YES) or a
 930 | # normal table of contents (NO) in the .chm file.
 931 |
 932 | BINARY_TOC             = NO
 933 |
 934 | # The TOC_EXPAND flag can be set to YES to add extra items for group members
 935 | # to the contents of the HTML help documentation and to the tree view.
 936 |
 937 | TOC_EXPAND             = NO
 938 |
 939 | # If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
 940 | # QHP_VIRTUAL_FOLDER are set, an additional index file will be generated
 941 | # that can be used as input for Qt's qhelpgenerator to generate a
 942 | # Qt Compressed Help (.qch) of the generated HTML documentation.
 943 |
 944 | GENERATE_QHP           = NO
 945 |
 946 | # If the QHG_LOCATION tag is specified, the QCH_FILE tag can
 947 | # be used to specify the file name of the resulting .qch file.
 948 | # The path specified is relative to the HTML output folder.
 949 |
 950 | QCH_FILE               =
 951 |
 952 | # The QHP_NAMESPACE tag specifies the namespace to use when generating
 953 | # Qt Help Project output. For more information please see
 954 | # http://doc.trolltech.com/qthelpproject.html#namespace
 955 |
 956 | QHP_NAMESPACE          = org.doxygen.Project
 957 |
 958 | # The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
 959 | # Qt Help Project output. For more information please see
 960 | # http://doc.trolltech.com/qthelpproject.html#virtual-folders
 961 |
 962 | QHP_VIRTUAL_FOLDER     = doc
 963 |
 964 | # If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to
 965 | # add. For more information please see
 966 | # http://doc.trolltech.com/qthelpproject.html#custom-filters
 967 |
 968 | QHP_CUST_FILTER_NAME   =
 969 |
 970 | # The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the
 971 | # custom filter to add. For more information please see
 972 | # <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">
 973 | # Qt Help Project / Custom Filters</a>.
 974 |
 975 | QHP_CUST_FILTER_ATTRS  =
 976 |
 977 | # The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
 978 | # project's
 979 | # filter section matches.
 980 | # <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">
 981 | # Qt Help Project / Filter Attributes</a>.
 982 |
 983 | QHP_SECT_FILTER_ATTRS  =
 984 |
 985 | # If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
 986 | # be used to specify the location of Qt's qhelpgenerator.
 987 | # If non-empty doxygen will try to run qhelpgenerator on the generated
 988 | # .qhp file.
 989 |
 990 | QHG_LOCATION           =
 991 |
 992 | # If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files
 993 | #  will be generated, which together with the HTML files, form an Eclipse help
 994 | # plugin. To install this plugin and make it available under the help contents
 995 | # menu in Eclipse, the contents of the directory containing the HTML and XML
 996 | # files needs to be copied into the plugins directory of eclipse. The name of
 997 | # the directory within the plugins directory should be the same as
 998 | # the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before
 999 | # the help appears.
1000 |
1001 | GENERATE_ECLIPSEHELP   = NO
1002 |
1003 | # A unique identifier for the eclipse help plugin. When installing the plugin
1004 | # the directory name containing the HTML and XML files should also have
1005 | # this name.
1006 |
1007 | ECLIPSE_DOC_ID         = org.doxygen.Project
1008 |
1009 | # The DISABLE_INDEX tag can be used to turn on/off the condensed index at
1010 | # top of each HTML page. The value NO (the default) enables the index and
1011 | # the value YES disables it.
1012 |
1013 | DISABLE_INDEX          = NO
1014 |
1015 | # This tag can be used to set the number of enum values (range [1..20])
1016 | # that doxygen will group on one line in the generated HTML documentation.
1017 |
1018 | ENUM_VALUES_PER_LINE   = 4
1019 |
1020 | # The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
1021 | # structure should be generated to display hierarchical information.
1022 | # If the tag value is set to YES, a side panel will be generated
1023 | # containing a tree-like index structure (just like the one that
1024 | # is generated for HTML Help). For this to work a browser that supports
1025 | # JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).
1026 | # Windows users are probably better off using the HTML help feature.
1027 |
1028 | GENERATE_TREEVIEW      = NO
1029 |
1030 | # By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories,
1031 | # and Class Hierarchy pages using a tree view instead of an ordered list.
1032 |
1033 | USE_INLINE_TREES       = NO
1034 |
1035 | # If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
1036 | # used to set the initial width (in pixels) of the frame in which the tree
1037 | # is shown.
1038 |
1039 | TREEVIEW_WIDTH         = 250
1040 |
1041 | # When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open
1042 | # links to external symbols imported via tag files in a separate window.
1043 |
1044 | EXT_LINKS_IN_WINDOW    = NO
1045 |
1046 | # Use this tag to change the font size of Latex formulas included
1047 | # as images in the HTML documentation. The default is 10. Note that
1048 | # when you change the font size after a successful doxygen run you need
1049 | # to manually remove any form_*.png images from the HTML output directory
1050 | # to force them to be regenerated.
1051 |
1052 | FORMULA_FONTSIZE       = 10
1053 |
1054 | # Use the FORMULA_TRANPARENT tag to determine whether or not the images
1055 | # generated for formulas are transparent PNGs. Transparent PNGs are
1056 | # not supported properly for IE 6.0, but are supported on all modern browsers.
1057 | # Note that when changing this option you need to delete any form_*.png files
1058 | # in the HTML output before the changes have effect.
1059 |
1060 | FORMULA_TRANSPARENT    = YES
1061 |
1062 | # When the SEARCHENGINE tag is enabled doxygen will generate a search box
1063 | # for the HTML output. The underlying search engine uses javascript
1064 | # and DHTML and should work on any modern browser. Note that when using
1065 | # HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets
1066 | # (GENERATE_DOCSET) there is already a search function so this one should
1067 | # typically be disabled. For large projects the javascript based search engine
1068 | # can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
1069 |
1070 | SEARCHENGINE           = YES
1071 |
1072 | # When the SERVER_BASED_SEARCH tag is enabled the search engine will be
1073 | # implemented using a PHP enabled web server instead of at the web client
1074 | # using Javascript. Doxygen will generate the search PHP script and index
1075 | # file to put on the web server. The advantage of the server
1076 | # based approach is that it scales better to large projects and allows
1077 | # full text search. The disadvances is that it is more difficult to setup
1078 | # and does not have live searching capabilities.
1079 |
1080 | SERVER_BASED_SEARCH    = NO
1081 |
1082 | #---------------------------------------------------------------------------
1083 | # configuration options related to the LaTeX output
1084 | #---------------------------------------------------------------------------
1085 |
1086 | # If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
1087 | # generate Latex output.
1088 |
1089 | GENERATE_LATEX         = NO
1090 |
1091 | # The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
1092 | # If a relative path is entered the value of OUTPUT_DIRECTORY will be
1093 | # put in front of it. If left blank `latex' will be used as the default path.
1094 |
1095 | LATEX_OUTPUT           = latex
1096 |
1097 | # The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
1098 | # invoked. If left blank `latex' will be used as the default command name.
1099 | # Note that when enabling USE_PDFLATEX this option is only used for
1100 | # generating bitmaps for formulas in the HTML output, but not in the
1101 | # Makefile that is written to the output directory.
1102 |
1103 | LATEX_CMD_NAME         = latex
1104 |
1105 | # The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
1106 | # generate index for LaTeX. If left blank `makeindex' will be used as the
1107 | # default command name.
1108 |
1109 | MAKEINDEX_CMD_NAME     = makeindex
1110 |
1111 | # If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
1112 | # LaTeX documents. This may be useful for small projects and may help to
1113 | # save some trees in general.
1114 |
1115 | COMPACT_LATEX          = NO
1116 |
1117 | # The PAPER_TYPE tag can be used to set the paper type that is used
1118 | # by the printer. Possible values are: a4, a4wide, letter, legal and
1119 | # executive. If left blank a4wide will be used.
1120 |
1121 | PAPER_TYPE             = a4wide
1122 |
1123 | # The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
1124 | # packages that should be included in the LaTeX output.
1125 |
1126 | EXTRA_PACKAGES         =
1127 |
1128 | # The LATEX_HEADER tag can be used to specify a personal LaTeX header for
1129 | # the generated latex document. The header should contain everything until
1130 | # the first chapter. If it is left blank doxygen will generate a
1131 | # standard header. Notice: only use this tag if you know what you are doing!
1132 |
1133 | LATEX_HEADER           =
1134 |
1135 | # If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
1136 | # is prepared for conversion to pdf (using ps2pdf). The pdf file will
1137 | # contain links (just like the HTML output) instead of page references
1138 | # This makes the output suitable for online browsing using a pdf viewer.
1139 |
1140 | PDF_HYPERLINKS         = YES
1141 |
1142 | # If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
1143 | # plain latex in the generated Makefile. Set this option to YES to get a
1144 | # higher quality PDF documentation.
1145 |
1146 | USE_PDFLATEX           = YES
1147 |
1148 | # If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
1149 | # command to the generated LaTeX files. This will instruct LaTeX to keep
1150 | # running if errors occur, instead of asking the user for help.
1151 | # This option is also used when generating formulas in HTML.
1152 |
1153 | LATEX_BATCHMODE        = NO
1154 |
1155 | # If LATEX_HIDE_INDICES is set to YES then doxygen will not
1156 | # include the index chapters (such as File Index, Compound Index, etc.)
1157 | # in the output.
1158 |
1159 | LATEX_HIDE_INDICES     = NO
1160 |
1161 | # If LATEX_SOURCE_CODE is set to YES then doxygen will include
1162 | # source code with syntax highlighting in the LaTeX output.
1163 | # Note that which sources are shown also depends on other settings
1164 | # such as SOURCE_BROWSER.
1165 |
1166 | LATEX_SOURCE_CODE      = NO
1167 |
1168 | #---------------------------------------------------------------------------
1169 | # configuration options related to the RTF output
1170 | #---------------------------------------------------------------------------
1171 |
1172 | # If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
1173 | # The RTF output is optimized for Word 97 and may not look very pretty with
1174 | # other RTF readers or editors.
1175 |
1176 | GENERATE_RTF           = NO
1177 |
1178 | # The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
1179 | # If a relative path is entered the value of OUTPUT_DIRECTORY will be
1180 | # put in front of it. If left blank `rtf' will be used as the default path.
1181 |
1182 | RTF_OUTPUT             = rtf
1183 |
1184 | # If the COMPACT_RTF tag is set to YES Doxygen generates more compact
1185 | # RTF documents. This may be useful for small projects and may help to
1186 | # save some trees in general.
1187 |
1188 | COMPACT_RTF            = NO
1189 |
1190 | # If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
1191 | # will contain hyperlink fields. The RTF file will
1192 | # contain links (just like the HTML output) instead of page references.
1193 | # This makes the output suitable for online browsing using WORD or other
1194 | # programs which support those fields.
1195 | # Note: wordpad (write) and others do not support links.
1196 |
1197 | RTF_HYPERLINKS         = NO
1198 |
1199 | # Load stylesheet definitions from file. Syntax is similar to doxygen's
1200 | # config file, i.e. a series of assignments. You only have to provide
1201 | # replacements, missing definitions are set to their default value.
1202 |
1203 | RTF_STYLESHEET_FILE    =
1204 |
1205 | # Set optional variables used in the generation of an rtf document.
1206 | # Syntax is similar to doxygen's config file.
1207 |
1208 | RTF_EXTENSIONS_FILE    =
1209 |
1210 | #---------------------------------------------------------------------------
1211 | # configuration options related to the man page output
1212 | #---------------------------------------------------------------------------
1213 |
1214 | # If the GENERATE_MAN tag is set to YES (the default) Doxygen will
1215 | # generate man pages
1216 |
1217 | GENERATE_MAN           = YES
1218 |
1219 | # The MAN_OUTPUT tag is used to specify where the man pages will be put.
1220 | # If a relative path is entered the value of OUTPUT_DIRECTORY will be
1221 | # put in front of it. If left blank `man' will be used as the default path.
1222 |
1223 | MAN_OUTPUT             = man
1224 |
1225 | # The MAN_EXTENSION tag determines the extension that is added to
1226 | # the generated man pages (default is the subroutine's section .3)
1227 |
1228 | MAN_EXTENSION          = .3
1229 |
1230 | # If the MAN_LINKS tag is set to YES and Doxygen generates man output,
1231 | # then it will generate one additional man file for each entity
1232 | # documented in the real man page(s). These additional files
1233 | # only source the real man page, but without them the man command
1234 | # would be unable to find the correct page. The default is NO.
1235 |
1236 | MAN_LINKS              = NO
1237 |
1238 | #---------------------------------------------------------------------------
1239 | # configuration options related to the XML output
1240 | #---------------------------------------------------------------------------
1241 |
1242 | # If the GENERATE_XML tag is set to YES Doxygen will
1243 | # generate an XML file that captures the structure of
1244 | # the code including all documentation.
1245 |
1246 | GENERATE_XML           = NO
1247 |
1248 | # The XML_OUTPUT tag is used to specify where the XML pages will be put.
1249 | # If a relative path is entered the value of OUTPUT_DIRECTORY will be
1250 | # put in front of it. If left blank `xml' will be used as the default path.
1251 |
1252 | XML_OUTPUT             = xml
1253 |
1254 | # The XML_SCHEMA tag can be used to specify an XML schema,
1255 | # which can be used by a validating XML parser to check the
1256 | # syntax of the XML files.
1257 |
1258 | XML_SCHEMA             =
1259 |
1260 | # The XML_DTD tag can be used to specify an XML DTD,
1261 | # which can be used by a validating XML parser to check the
1262 | # syntax of the XML files.
1263 |
1264 | XML_DTD                =
1265 |
1266 | # If the XML_PROGRAMLISTING tag is set to YES Doxygen will
1267 | # dump the program listings (including syntax highlighting
1268 | # and cross-referencing information) to the XML output. Note that
1269 | # enabling this will significantly increase the size of the XML output.
1270 |
1271 | XML_PROGRAMLISTING     = YES
1272 |
1273 | #---------------------------------------------------------------------------
1274 | # configuration options for the AutoGen Definitions output
1275 | #---------------------------------------------------------------------------
1276 |
1277 | # If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
1278 | # generate an AutoGen Definitions (see autogen.sf.net) file
1279 | # that captures the structure of the code including all
1280 | # documentation. Note that this feature is still experimental
1281 | # and incomplete at the moment.
1282 |
1283 | GENERATE_AUTOGEN_DEF   = NO
1284 |
1285 | #---------------------------------------------------------------------------
1286 | # configuration options related to the Perl module output
1287 | #---------------------------------------------------------------------------
1288 |
1289 | # If the GENERATE_PERLMOD tag is set to YES Doxygen will
1290 | # generate a Perl module file that captures the structure of
1291 | # the code including all documentation. Note that this
1292 | # feature is still experimental and incomplete at the
1293 | # moment.
1294 |
1295 | GENERATE_PERLMOD       = NO
1296 |
1297 | # If the PERLMOD_LATEX tag is set to YES Doxygen will generate
1298 | # the necessary Makefile rules, Perl scripts and LaTeX code to be able
1299 | # to generate PDF and DVI output from the Perl module output.
1300 |
1301 | PERLMOD_LATEX          = NO
1302 |
1303 | # If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
1304 | # nicely formatted so it can be parsed by a human reader.
1305 | # This is useful
1306 | # if you want to understand what is going on.
1307 | # On the other hand, if this
1308 | # tag is set to NO the size of the Perl module output will be much smaller
1309 | # and Perl will parse it just the same.
1310 |
1311 | PERLMOD_PRETTY         = YES
1312 |
1313 | # The names of the make variables in the generated doxyrules.make file
1314 | # are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
1315 | # This is useful so different doxyrules.make files included by the same
1316 | # Makefile don't overwrite each other's variables.
1317 |
1318 | PERLMOD_MAKEVAR_PREFIX =
1319 |
1320 | #---------------------------------------------------------------------------
1321 | # Configuration options related to the preprocessor
1322 | #---------------------------------------------------------------------------
1323 |
1324 | # If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
1325 | # evaluate all C-preprocessor directives found in the sources and include
1326 | # files.
1327 |
1328 | ENABLE_PREPROCESSING   = YES
1329 |
1330 | # If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
1331 | # names in the source code. If set to NO (the default) only conditional
1332 | # compilation will be performed. Macro expansion can be done in a controlled
1333 | # way by setting EXPAND_ONLY_PREDEF to YES.
1334 |
1335 | MACRO_EXPANSION        = NO
1336 |
1337 | # If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
1338 | # then the macro expansion is limited to the macros specified with the
1339 | # PREDEFINED and EXPAND_AS_DEFINED tags.
1340 |
1341 | EXPAND_ONLY_PREDEF     = NO
1342 |
1343 | # If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
1344 | # in the INCLUDE_PATH (see below) will be search if a #include is found.
1345 |
1346 | SEARCH_INCLUDES        = YES
1347 |
1348 | # The INCLUDE_PATH tag can be used to specify one or more directories that
1349 | # contain include files that are not input files but should be processed by
1350 | # the preprocessor.
1351 |
1352 | INCLUDE_PATH           =
1353 |
1354 | # You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
1355 | # patterns (like *.h and *.hpp) to filter out the header-files in the
1356 | # directories. If left blank, the patterns specified with FILE_PATTERNS will
1357 | # be used.
1358 |
1359 | INCLUDE_FILE_PATTERNS  =
1360 |
1361 | # The PREDEFINED tag can be used to specify one or more macro names that
1362 | # are defined before the preprocessor is started (similar to the -D option of
1363 | # gcc). The argument of the tag is a list of macros of the form: name
1364 | # or name=definition (no spaces). If the definition and the = are
1365 | # omitted =1 is assumed. To prevent a macro definition from being
1366 | # undefined via #undef or recursively expanded use the := operator
1367 | # instead of the = operator.
1368 |
1369 | PREDEFINED             = DEBUG=2 __GNUC__=1
1370 |
1371 | # If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
1372 | # this tag can be used to specify a list of macro names that should be expanded.
1373 | # The macro definition that is found in the sources will be used.
1374 | # Use the PREDEFINED tag if you want to use a different macro definition.
1375 |
1376 | EXPAND_AS_DEFINED      =
1377 |
1378 | # If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
1379 | # doxygen's preprocessor will remove all function-like macros that are alone
1380 | # on a line, have an all uppercase name, and do not end with a semicolon. Such
1381 | # function macros are typically used for boiler-plate code, and will confuse
1382 | # the parser if not removed.
1383 |
1384 | SKIP_FUNCTION_MACROS   = YES
1385 |
1386 | #---------------------------------------------------------------------------
1387 | # Configuration::additions related to external references
1388 | #---------------------------------------------------------------------------
1389 |
1390 | # The TAGFILES option can be used to specify one or more tagfiles.
1391 | # Optionally an initial location of the external documentation
1392 | # can be added for each tagfile. The format of a tag file without
1393 | # this location is as follows:
1394 | #
1395 | # TAGFILES = file1 file2 ...
1396 | # Adding location for the tag files is done as follows:
1397 | #
1398 | # TAGFILES = file1=loc1 "file2 = loc2" ...
1399 | # where "loc1" and "loc2" can be relative or absolute paths or
1400 | # URLs. If a location is present for each tag, the installdox tool
1401 | # does not have to be run to correct the links.
1402 | # Note that each tag file must have a unique name
1403 | # (where the name does NOT include the path)
1404 | # If a tag file is not located in the directory in which doxygen
1405 | # is run, you must also specify the path to the tagfile here.
1406 |
1407 | TAGFILES               = tooltag=./man1
1408 |
1409 | # When a file name is specified after GENERATE_TAGFILE, doxygen will create
1410 | # a tag file that is based on the input files it reads.
1411 |
1412 | GENERATE_TAGFILE       =
1413 |
1414 | # If the ALLEXTERNALS tag is set to YES all external classes will be listed
1415 | # in the class index. If set to NO only the inherited external classes
1416 | # will be listed.
1417 |
1418 | ALLEXTERNALS           = NO
1419 |
1420 | # If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
1421 | # in the modules index. If set to NO, only the current project's groups will
1422 | # be listed.
1423 |
1424 | EXTERNAL_GROUPS        = YES
1425 |
1426 | # The PERL_PATH should be the absolute path and name of the perl script
1427 | # interpreter (i.e. the result of `which perl').
1428 |
1429 | PERL_PATH              = /usr/bin/perl
1430 |
1431 | #---------------------------------------------------------------------------
1432 | # Configuration options related to the dot tool
1433 | #---------------------------------------------------------------------------
1434 |
1435 | # If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
1436 | # generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
1437 | # or super classes. Setting the tag to NO turns the diagrams off. Note that
1438 | # this option is superseded by the HAVE_DOT option below. This is only a
1439 | # fallback. It is recommended to install and use dot, since it yields more
1440 | # powerful graphs.
1441 |
1442 | CLASS_DIAGRAMS         = YES
1443 |
1444 | # You can define message sequence charts within doxygen comments using the \msc
1445 | # command. Doxygen will then run the mscgen tool (see
1446 | # http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
1447 | # documentation. The MSCGEN_PATH tag allows you to specify the directory where
1448 | # the mscgen tool resides. If left empty the tool is assumed to be found in the
1449 | # default search path.
1450 |
1451 | MSCGEN_PATH            =
1452 |
1453 | # If set to YES, the inheritance and collaboration graphs will hide
1454 | # inheritance and usage relations if the target is undocumented
1455 | # or is not a class.
1456 |
1457 | HIDE_UNDOC_RELATIONS   = YES
1458 |
1459 | # If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
1460 | # available from the path. This tool is part of Graphviz, a graph visualization
1461 | # toolkit from AT&T and Lucent Bell Labs. The other options in this section
1462 | # have no effect if this option is set to NO (the default)
1463 |
1464 | HAVE_DOT               = NO
1465 |
1466 | # The DOT_NUM_THREADS specifies the number of dot invocations doxygen is
1467 | # allowed to run in parallel. When set to 0 (the default) doxygen will
1468 | # base this on the number of processors available in the system. You can set it
1469 | # explicitly to a value larger than 0 to get control over the balance
1470 | # between CPU load and processing speed.
1471 |
1472 | DOT_NUM_THREADS        = 0
1473 |
1474 | # By default doxygen will write a font called FreeSans.ttf to the output
1475 | # directory and reference it in all dot files that doxygen generates. This
1476 | # font does not include all possible unicode characters however, so when you need
1477 | # these (or just want a differently looking font) you can specify the font name
1478 | # using DOT_FONTNAME. You need need to make sure dot is able to find the font,
1479 | # which can be done by putting it in a standard location or by setting the
1480 | # DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory
1481 | # containing the font.
1482 |
1483 | DOT_FONTNAME           = FreeSans.ttf
1484 |
1485 | # The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
1486 | # The default size is 10pt.
1487 |
1488 | DOT_FONTSIZE           = 10
1489 |
1490 | # By default doxygen will tell dot to use the output directory to look for the
1491 | # FreeSans.ttf font (which doxygen will put there itself). If you specify a
1492 | # different font using DOT_FONTNAME you can set the path where dot
1493 | # can find it using this tag.
1494 |
1495 | DOT_FONTPATH           =
1496 |
1497 | # If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
1498 | # will generate a graph for each documented class showing the direct and
1499 | # indirect inheritance relations. Setting this tag to YES will force the
1500 | # the CLASS_DIAGRAMS tag to NO.
1501 |
1502 | CLASS_GRAPH            = YES
1503 |
1504 | # If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
1505 | # will generate a graph for each documented class showing the direct and
1506 | # indirect implementation dependencies (inheritance, containment, and
1507 | # class references variables) of the class with other documented classes.
1508 |
1509 | COLLABORATION_GRAPH    = YES
1510 |
1511 | # If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
1512 | # will generate a graph for groups, showing the direct groups dependencies
1513 |
1514 | GROUP_GRAPHS           = YES
1515 |
1516 | # If the UML_LOOK tag is set to YES doxygen will generate inheritance and
1517 | # collaboration diagrams in a style similar to the OMG's Unified Modeling
1518 | # Language.
1519 |
1520 | UML_LOOK               = NO
1521 |
1522 | # If set to YES, the inheritance and collaboration graphs will show the
1523 | # relations between templates and their instances.
1524 |
1525 | TEMPLATE_RELATIONS     = NO
1526 |
1527 | # If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
1528 | # tags are set to YES then doxygen will generate a graph for each documented
1529 | # file showing the direct and indirect include dependencies of the file with
1530 | # other documented files.
1531 |
1532 | INCLUDE_GRAPH          = YES
1533 |
1534 | # If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
1535 | # HAVE_DOT tags are set to YES then doxygen will generate a graph for each
1536 | # documented header file showing the documented files that directly or
1537 | # indirectly include this file.
1538 |
1539 | INCLUDED_BY_GRAPH      = YES
1540 |
1541 | # If the CALL_GRAPH and HAVE_DOT options are set to YES then
1542 | # doxygen will generate a call dependency graph for every global function
1543 | # or class method. Note that enabling this option will significantly increase
1544 | # the time of a run. So in most cases it will be better to enable call graphs
1545 | # for selected functions only using the \callgraph command.
1546 |
1547 | CALL_GRAPH             = NO
1548 |
1549 | # If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
1550 | # doxygen will generate a caller dependency graph for every global function
1551 | # or class method. Note that enabling this option will significantly increase
1552 | # the time of a run. So in most cases it will be better to enable caller
1553 | # graphs for selected functions only using the \callergraph command.
1554 |
1555 | CALLER_GRAPH           = NO
1556 |
1557 | # If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
1558 | # will graphical hierarchy of all classes instead of a textual one.
1559 |
1560 | GRAPHICAL_HIERARCHY    = YES
1561 |
1562 | # If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES
1563 | # then doxygen will show the dependencies a directory has on other directories
1564 | # in a graphical way. The dependency relations are determined by the #include
1565 | # relations between the files in the directories.
1566 |
1567 | DIRECTORY_GRAPH        = YES
1568 |
1569 | # The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
1570 | # generated by dot. Possible values are png, jpg, or gif
1571 | # If left blank png will be used.
1572 |
1573 | DOT_IMAGE_FORMAT       = png
1574 |
1575 | # The tag DOT_PATH can be used to specify the path where the dot tool can be
1576 | # found. If left blank, it is assumed the dot tool can be found in the path.
1577 |
1578 | DOT_PATH               =
1579 |
1580 | # The DOTFILE_DIRS tag can be used to specify one or more directories that
1581 | # contain dot files that are included in the documentation (see the
1582 | # \dotfile command).
1583 |
1584 | DOTFILE_DIRS           =
1585 |
1586 | # The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
1587 | # nodes that will be shown in the graph. If the number of nodes in a graph
1588 | # becomes larger than this value, doxygen will truncate the graph, which is
1589 | # visualized by representing a node as a red box. Note that doxygen if the
1590 | # number of direct children of the root node in a graph is already larger than
1591 | # DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
1592 | # that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
1593 |
1594 | DOT_GRAPH_MAX_NODES    = 50
1595 |
1596 | # The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
1597 | # graphs generated by dot. A depth value of 3 means that only nodes reachable
1598 | # from the root by following a path via at most 3 edges will be shown. Nodes
1599 | # that lay further from the root node will be omitted. Note that setting this
1600 | # option to 1 or 2 may greatly reduce the computation time needed for large
1601 | # code bases. Also note that the size of a graph can be further restricted by
1602 | # DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
1603 |
1604 | MAX_DOT_GRAPH_DEPTH    = 0
1605 |
1606 | # Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
1607 | # background. This is disabled by default, because dot on Windows does not
1608 | # seem to support this out of the box. Warning: Depending on the platform used,
1609 | # enabling this option may lead to badly anti-aliased labels on the edges of
1610 | # a graph (i.e. they become hard to read).
1611 |
1612 | DOT_TRANSPARENT        = NO
1613 |
1614 | # Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
1615 | # files in one run (i.e. multiple -o and -T options on the command line). This
1616 | # makes dot run faster, but since only newer versions of dot (>1.8.10)
1617 | # support this, this feature is disabled by default.
1618 |
1619 | DOT_MULTI_TARGETS      = YES
1620 |
1621 | # If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
1622 | # generate a legend page explaining the meaning of the various boxes and
1623 | # arrows in the dot generated graphs.
1624 |
1625 | GENERATE_LEGEND        = YES
1626 |
1627 | # If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
1628 | # remove the intermediate dot files that are used to generate
1629 | # the various graphs.
1630 |
1631 | DOT_CLEANUP            = YES
1632 |


--------------------------------------------------------------------------------
/libraries/liblmdb/LICENSE:
--------------------------------------------------------------------------------
 1 | The OpenLDAP Public License
 2 |   Version 2.8, 17 August 2003
 3 |
 4 | Redistribution and use of this software and associated documentation
 5 | ("Software"), with or without modification, are permitted provided
 6 | that the following conditions are met:
 7 |
 8 | 1. Redistributions in source form must retain copyright statements
 9 |    and notices,
10 |
11 | 2. Redistributions in binary form must reproduce applicable copyright
12 |    statements and notices, this list of conditions, and the following
13 |    disclaimer in the documentation and/or other materials provided
14 |    with the distribution, and
15 |
16 | 3. Redistributions must contain a verbatim copy of this document.
17 |
18 | The OpenLDAP Foundation may revise this license from time to time.
19 | Each revision is distinguished by a version number.  You may use
20 | this Software under terms of this license revision or under the
21 | terms of any subsequent revision of the license.
22 |
23 | THIS SOFTWARE IS PROVIDED BY THE OPENLDAP FOUNDATION AND ITS
24 | CONTRIBUTORS ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
25 | INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
26 | AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT
27 | SHALL THE OPENLDAP FOUNDATION, ITS CONTRIBUTORS, OR THE AUTHOR(S)
28 | OR OWNER(S) OF THE SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
29 | INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
30 | BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
31 | LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
32 | CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
33 | LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
34 | ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
35 | POSSIBILITY OF SUCH DAMAGE.
36 |
37 | The names of the authors and copyright holders must not be used in
38 | advertising or otherwise to promote the sale, use or other dealing
39 | in this Software without specific, written prior permission.  Title
40 | to copyright in this Software shall at all times remain with copyright
41 | holders.
42 |
43 | OpenLDAP is a registered trademark of the OpenLDAP Foundation.
44 |
45 | Copyright 1999-2003 The OpenLDAP Foundation, Redwood City,
46 | California, USA.  All Rights Reserved.  Permission to copy and
47 | distribute verbatim copies of this document is granted.
48 |


--------------------------------------------------------------------------------
/libraries/liblmdb/Makefile:
--------------------------------------------------------------------------------
  1 | # Makefile for liblmdb (Lightning memory-mapped database library).
  2 |
  3 | ########################################################################
  4 | # Configuration. The compiler options must enable threaded compilation.
  5 | #
  6 | # Preprocessor macros (for CPPFLAGS) of interest...
  7 | # Note that the defaults should already be correct for most
  8 | # platforms; you should not need to change any of these.
  9 | # Read their descriptions in mdb.c if you do:
 10 | #
 11 | # - MDB_USE_POSIX_MUTEX, MDB_USE_POSIX_SEM, MDB_USE_SYSV_SEM
 12 | # - MDB_DSYNC
 13 | # - MDB_FDATASYNC
 14 | # - MDB_FDATASYNC_WORKS
 15 | # - MDB_USE_PWRITEV
 16 | # - MDB_USE_ROBUST
 17 | #
 18 | # There may be other macros in mdb.c of interest. You should
 19 | # read mdb.c before changing any of them.
 20 | #
 21 | CC	= gcc
 22 | AR	= ar
 23 | W	= -W -Wall -Wno-unused-parameter -Wbad-function-cast -Wuninitialized
 24 | THREADS = -pthread
 25 | OPT = -O2 -g
 26 | CFLAGS	= $(THREADS) $(OPT) $(W) $(XCFLAGS)
 27 | LDLIBS	=
 28 | SOLIBS	=
 29 | SOEXT	= .so
 30 | prefix	= /usr/local
 31 | exec_prefix = $(prefix)
 32 | bindir = $(exec_prefix)/bin
 33 | libdir = $(exec_prefix)/lib
 34 | includedir = $(prefix)/include
 35 | datarootdir = $(prefix)/share
 36 | mandir = $(datarootdir)/man
 37 |
 38 | ########################################################################
 39 |
 40 | IHDRS	= lmdb.h
 41 | ILIBS	= liblmdb.a liblmdb$(SOEXT)
 42 | IPROGS	= mdb_stat mdb_copy mdb_dump mdb_load mdb_drop
 43 | IDOCS	= mdb_stat.1 mdb_copy.1 mdb_dump.1 mdb_load.1 mdb_drop.1
 44 | PROGS	= $(IPROGS) mtest mtest2 mtest3 mtest4 mtest5
 45 | all:	$(ILIBS) $(PROGS)
 46 |
 47 | install: $(ILIBS) $(IPROGS) $(IHDRS)
 48 | 	mkdir -p $(DESTDIR)$(bindir)
 49 | 	mkdir -p $(DESTDIR)$(libdir)
 50 | 	mkdir -p $(DESTDIR)$(includedir)
 51 | 	mkdir -p $(DESTDIR)$(mandir)/man1
 52 | 	for f in $(IPROGS); do cp $f $(DESTDIR)$(bindir); done
 53 | 	for f in $(ILIBS); do cp $f $(DESTDIR)$(libdir); done
 54 | 	for f in $(IHDRS); do cp $f $(DESTDIR)$(includedir); done
 55 | 	for f in $(IDOCS); do cp $f $(DESTDIR)$(mandir)/man1; done
 56 |
 57 | clean:
 58 | 	rm -rf $(PROGS) *.[ao] *.[ls]o *~ testdb
 59 |
 60 | test:	all
 61 | 	rm -rf testdb && mkdir testdb
 62 | 	./mtest && ./mdb_stat testdb
 63 |
 64 | liblmdb.a:	mdb.o midl.o
 65 | 	$(AR) rs $@ mdb.o midl.o
 66 |
 67 | liblmdb$(SOEXT):	mdb.lo midl.lo
 68 | #	$(CC) $(LDFLAGS) -pthread -shared -Wl,-Bsymbolic -o $@ mdb.o midl.o $(SOLIBS)
 69 | 	$(CC) $(LDFLAGS) -pthread -shared -o $@ mdb.lo midl.lo $(SOLIBS)
 70 |
 71 | mdb_stat: mdb_stat.o liblmdb.a
 72 | mdb_copy: mdb_copy.o liblmdb.a
 73 | mdb_dump: mdb_dump.o liblmdb.a
 74 | mdb_load: mdb_load.o liblmdb.a
 75 | mdb_drop: mdb_drop.o liblmdb.a
 76 | mtest:    mtest.o    liblmdb.a
 77 | mtest2:	mtest2.o liblmdb.a
 78 | mtest3:	mtest3.o liblmdb.a
 79 | mtest4:	mtest4.o liblmdb.a
 80 | mtest5:	mtest5.o liblmdb.a
 81 | mtest6:	mtest6.o liblmdb.a
 82 | mplay:	mplay.o liblmdb.a
 83 |
 84 | mdb.o: mdb.c lmdb.h midl.h
 85 | 	$(CC) $(CFLAGS) $(CPPFLAGS) -c mdb.c
 86 |
 87 | midl.o: midl.c midl.h
 88 | 	$(CC) $(CFLAGS) $(CPPFLAGS) -c midl.c
 89 |
 90 | mdb.lo: mdb.c lmdb.h midl.h
 91 | 	$(CC) $(CFLAGS) -fPIC $(CPPFLAGS) -c mdb.c -o $@
 92 |
 93 | midl.lo: midl.c midl.h
 94 | 	$(CC) $(CFLAGS) -fPIC $(CPPFLAGS) -c midl.c -o $@
 95 |
 96 | %:	%.o
 97 | 	$(CC) $(CFLAGS) $(LDFLAGS) $^ $(LDLIBS) -o $@
 98 |
 99 | %.o:	%.c lmdb.h
100 | 	$(CC) $(CFLAGS) $(CPPFLAGS) -c
lt;
101 |
102 | COV_FLAGS=-fprofile-arcs -ftest-coverage
103 | COV_OBJS=xmdb.o xmidl.o
104 |
105 | coverage: xmtest
106 | 	for i in mtest*.c [0-9]*.c; do j=`basename \$i .c`; $(MAKE) $j.o; \
107 | 		gcc -o x$j $j.o $(COV_OBJS) -pthread $(COV_FLAGS); \
108 | 		rm -rf testdb; mkdir testdb; ./x$j; done
109 | 	gcov xmdb.c
110 | 	gcov xmidl.c
111 |
112 | xmtest:	mtest.o xmdb.o xmidl.o
113 | 	gcc -o xmtest mtest.o xmdb.o xmidl.o -pthread $(COV_FLAGS)
114 |
115 | xmdb.o: mdb.c lmdb.h midl.h
116 | 	$(CC) $(CFLAGS) -fPIC $(CPPFLAGS) -O0 $(COV_FLAGS) -c mdb.c -o $@
117 |
118 | xmidl.o: midl.c midl.h
119 | 	$(CC) $(CFLAGS) -fPIC $(CPPFLAGS) -O0 $(COV_FLAGS) -c midl.c -o $@
120 |


--------------------------------------------------------------------------------
/libraries/liblmdb/intro.doc:
--------------------------------------------------------------------------------
  1 | /*
  2 |  * Copyright 2015-2021 Howard Chu, Symas Corp.
  3 |  * All rights reserved.
  4 |  *
  5 |  * Redistribution and use in source and binary forms, with or without
  6 |  * modification, are permitted only as authorized by the OpenLDAP
  7 |  * Public License.
  8 |  *
  9 |  * A copy of this license is available in the file LICENSE in the
 10 |  * top-level directory of the distribution or, alternatively, at
 11 |  * <http://www.OpenLDAP.org/license.html>.
 12 |  */
 13 | /** @page starting Getting Started
 14 |
 15 | LMDB is compact, fast, powerful, and robust and implements a simplified
 16 | variant of the BerkeleyDB (BDB) API. (BDB is also very powerful, and verbosely
 17 | documented in its own right.) After reading this page, the main
 18 | \ref mdb documentation should make sense. Thanks to Bert Hubert
 19 | for creating the
 20 | <a href="https://github.com/ahupowerdns/ahutils/blob/master/lmdb-semantics.md">
 21 | initial version</a> of this writeup.
 22 |
 23 | Everything starts with an environment, created by #mdb_env_create().
 24 | Once created, this environment must also be opened with #mdb_env_open().
 25 |
 26 | #mdb_env_open() gets passed a name which is interpreted as a directory
 27 | path. Note that this directory must exist already, it is not created
 28 | for you. Within that directory, a lock file and a storage file will be
 29 | generated. If you don't want to use a directory, you can pass the
 30 | #MDB_NOSUBDIR option, in which case the path you provided is used
 31 | directly as the data file, and another file with a "-lock" suffix
 32 | added will be used for the lock file.
 33 |
 34 | Once the environment is open, a transaction can be created within it
 35 | using #mdb_txn_begin(). Transactions may be read-write or read-only,
 36 | and read-write transactions may be nested. A transaction must only
 37 | be used by one thread at a time. Transactions are always required,
 38 | even for read-only access. The transaction provides a consistent
 39 | view of the data.
 40 |
 41 | Once a transaction has been created, a database can be opened within it
 42 | using #mdb_dbi_open(). If only one database will ever be used in the
 43 | environment, a NULL can be passed as the database name. For named
 44 | databases, the #MDB_CREATE flag must be used to create the database
 45 | if it doesn't already exist. Also, #mdb_env_set_maxdbs() must be
 46 | called after #mdb_env_create() and before #mdb_env_open() to set the
 47 | maximum number of named databases you want to support.
 48 |
 49 | Note: a single transaction can open multiple databases. Generally
 50 | databases should only be opened once, by the first transaction in
 51 | the process. After the first transaction completes, the database
 52 | handles can freely be used by all subsequent transactions.
 53 |
 54 | Within a transaction, #mdb_get() and #mdb_put() can store single
 55 | key/value pairs if that is all you need to do (but see \ref Cursors
 56 | below if you want to do more).
 57 |
 58 | A key/value pair is expressed as two #MDB_val structures. This struct
 59 | has two fields, \c mv_size and \c mv_data. The data is a \c void pointer to
 60 | an array of \c mv_size bytes.
 61 |
 62 | Because LMDB is very efficient (and usually zero-copy), the data returned
 63 | in an #MDB_val structure may be memory-mapped straight from disk. In
 64 | other words <b>look but do not touch</b> (or free() for that matter).
 65 | Once a transaction is closed, the values can no longer be used, so
 66 | make a copy if you need to keep them after that.
 67 |
 68 | @section Cursors Cursors
 69 |
 70 | To do more powerful things, we must use a cursor.
 71 |
 72 | Within the transaction, a cursor can be created with #mdb_cursor_open().
 73 | With this cursor we can store/retrieve/delete (multiple) values using
 74 | #mdb_cursor_get(), #mdb_cursor_put(), and #mdb_cursor_del().
 75 |
 76 | #mdb_cursor_get() positions itself depending on the cursor operation
 77 | requested, and for some operations, on the supplied key. For example,
 78 | to list all key/value pairs in a database, use operation #MDB_FIRST for
 79 | the first call to #mdb_cursor_get(), and #MDB_NEXT on subsequent calls,
 80 | until the end is hit.
 81 |
 82 | To retrieve all keys starting from a specified key value, use #MDB_SET.
 83 | For more cursor operations, see the \ref mdb docs.
 84 |
 85 | When using #mdb_cursor_put(), either the function will position the
 86 | cursor for you based on the \b key, or you can use operation
 87 | #MDB_CURRENT to use the current position of the cursor. Note that
 88 | \b key must then match the current position's key.
 89 |
 90 | @subsection summary Summarizing the Opening
 91 |
 92 | So we have a cursor in a transaction which opened a database in an
 93 | environment which is opened from a filesystem after it was
 94 | separately created.
 95 |
 96 | Or, we create an environment, open it from a filesystem, create a
 97 | transaction within it, open a database within that transaction,
 98 | and create a cursor within all of the above.
 99 |
100 | Got it?
101 |
102 | @section thrproc Threads and Processes
103 |
104 | LMDB uses POSIX locks on files, and these locks have issues if one
105 | process opens a file multiple times. Because of this, do not
106 | #mdb_env_open() a file multiple times from a single process. Instead,
107 | share the LMDB environment that has opened the file across all threads.
108 | Otherwise, if a single process opens the same environment multiple times,
109 | closing it once will remove all the locks held on it, and the other
110 | instances will be vulnerable to corruption from other processes.
111 |
112 | Also note that a transaction is tied to one thread by default using
113 | Thread Local Storage. If you want to pass read-only transactions across
114 | threads, you can use the #MDB_NOTLS option on the environment.
115 |
116 | @section txns Transactions, Rollbacks, etc.
117 |
118 | To actually get anything done, a transaction must be committed using
119 | #mdb_txn_commit(). Alternatively, all of a transaction's operations
120 | can be discarded using #mdb_txn_abort(). In a read-only transaction,
121 | any cursors will \b not automatically be freed. In a read-write
122 | transaction, all cursors will be freed and must not be used again.
123 |
124 | For read-only transactions, obviously there is nothing to commit to
125 | storage. The transaction still must eventually be aborted to close
126 | any database handle(s) opened in it, or committed to keep the
127 | database handles around for reuse in new transactions.
128 |
129 | In addition, as long as a transaction is open, a consistent view of
130 | the database is kept alive, which requires storage. A read-only
131 | transaction that no longer requires this consistent view should
132 | be terminated (committed or aborted) when the view is no longer
133 | needed (but see below for an optimization).
134 |
135 | There can be multiple simultaneously active read-only transactions
136 | but only one that can write. Once a single read-write transaction
137 | is opened, all further attempts to begin one will block until the
138 | first one is committed or aborted. This has no effect on read-only
139 | transactions, however, and they may continue to be opened at any time.
140 |
141 | @section dupkeys Duplicate Keys
142 |
143 | #mdb_get() and #mdb_put() respectively have no and only some support
144 | for multiple key/value pairs with identical keys. If there are multiple
145 | values for a key, #mdb_get() will only return the first value.
146 |
147 | When multiple values for one key are required, pass the #MDB_DUPSORT
148 | flag to #mdb_dbi_open(). In an #MDB_DUPSORT database, by default
149 | #mdb_put() will not replace the value for a key if the key existed
150 | already. Instead it will add the new value to the key. In addition,
151 | #mdb_del() will pay attention to the value field too, allowing for
152 | specific values of a key to be deleted.
153 |
154 | Finally, additional cursor operations become available for
155 | traversing through and retrieving duplicate values.
156 |
157 | @section optim Some Optimization
158 |
159 | If you frequently begin and abort read-only transactions, as an
160 | optimization, it is possible to only reset and renew a transaction.
161 |
162 | #mdb_txn_reset() releases any old copies of data kept around for
163 | a read-only transaction. To reuse this reset transaction, call
164 | #mdb_txn_renew() on it. Any cursors in this transaction must also
165 | be renewed using #mdb_cursor_renew().
166 |
167 | Note that #mdb_txn_reset() is similar to #mdb_txn_abort() and will
168 | close any databases you opened within the transaction.
169 |
170 | To permanently free a transaction, reset or not, use #mdb_txn_abort().
171 |
172 | @section cleanup Cleaning Up
173 |
174 | For read-only transactions, any cursors created within it must
175 | be closed using #mdb_cursor_close().
176 |
177 | It is very rarely necessary to close a database handle, and in
178 | general they should just be left open.
179 |
180 | @section onward The Full API
181 |
182 | The full \ref mdb documentation lists further details, like how to:
183 |
184 |   \li size a database (the default limits are intentionally small)
185 |   \li drop and clean a database
186 |   \li detect and report errors
187 |   \li optimize (bulk) loading speed
188 |   \li (temporarily) reduce robustness to gain even more speed
189 |   \li gather statistics about the database
190 |   \li define custom sort orders
191 |
192 | */
193 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_copy.1:
--------------------------------------------------------------------------------
 1 | .TH MDB_COPY 1 "2017/07/31" "LMDB 0.9.70"
 2 | .\" Copyright 2012-2021 Howard Chu, Symas Corp. All Rights Reserved.
 3 | .\" Copying restrictions apply.  See COPYRIGHT/LICENSE.
 4 | .SH NAME
 5 | mdb_copy \- LMDB environment copy tool
 6 | .SH SYNOPSIS
 7 | .B mdb_copy
 8 | [\c
 9 | .BR \-V ]
10 | [\c
11 | .BR \-c ]
12 | [\c
13 | .BR \-n ]
14 | [\c
15 | .BR \-v ]
16 | .B srcpath
17 | [\c
18 | .BR dstpath ]
19 | .SH DESCRIPTION
20 | The
21 | .B mdb_copy
22 | utility copies an LMDB environment. The environment can
23 | be copied regardless of whether it is currently in use.
24 | No lockfile is created, since it gets recreated at need.
25 |
26 | If
27 | .I dstpath
28 | is specified it must be the path of an empty directory
29 | for storing the backup. Otherwise, the backup will be
30 | written to stdout.
31 |
32 | .SH OPTIONS
33 | .TP
34 | .BR \-V
35 | Write the library version number to the standard output, and exit.
36 | .TP
37 | .BR \-c
38 | Compact while copying. Only current data pages will be copied; freed
39 | or unused pages will be omitted from the copy. This option will
40 | slow down the backup process as it is more CPU-intensive.
41 | Currently it fails if the environment has suffered a page leak.
42 | .TP
43 | .BR \-n
44 | Open LDMB environment(s) which do not use subdirectories.
45 | .TP
46 | .BR \-v
47 | Use the previous environment state instead of the latest state.
48 | This may be useful if the latest state has been corrupted.
49 |
50 | .SH DIAGNOSTICS
51 | Exit status is zero if no errors occur.
52 | Errors result in a non-zero exit status and
53 | a diagnostic message being written to standard error.
54 | .SH CAVEATS
55 | This utility can trigger significant file size growth if run
56 | in parallel with write transactions, because pages which they
57 | free during copying cannot be reused until the copy is done.
58 | .SH "SEE ALSO"
59 | .BR mdb_stat (1)
60 | .SH AUTHOR
61 | Howard Chu of Symas Corporation <http://www.symas.com>
62 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_copy.c:
--------------------------------------------------------------------------------
 1 | /* mdb_copy.c - memory-mapped database backup tool */
 2 | /*
 3 |  * Copyright 2012-2021 Howard Chu, Symas Corp.
 4 |  * All rights reserved.
 5 |  *
 6 |  * Redistribution and use in source and binary forms, with or without
 7 |  * modification, are permitted only as authorized by the OpenLDAP
 8 |  * Public License.
 9 |  *
10 |  * A copy of this license is available in the file LICENSE in the
11 |  * top-level directory of the distribution or, alternatively, at
12 |  * <http://www.OpenLDAP.org/license.html>.
13 |  */
14 | #ifdef _WIN32
15 | #include <windows.h>
16 | #define	MDB_STDOUT	GetStdHandle(STD_OUTPUT_HANDLE)
17 | #else
18 | #define	MDB_STDOUT	1
19 | #endif
20 | #include <stdio.h>
21 | #include <stdlib.h>
22 | #include <signal.h>
23 | #include "lmdb.h"
24 |
25 | static void
26 | sighandle(int sig)
27 | {
28 | }
29 |
30 | int main(int argc,char * argv[])
31 | {
32 | 	int rc;
33 | 	MDB_env *env;
34 | 	const char *progname = argv[0], *act;
35 | 	unsigned flags = MDB_RDONLY;
36 | 	unsigned cpflags = 0;
37 |
38 | 	for (; argc > 1 && argv[1][0] == '-'; argc--, argv++) {
39 | 		if (argv[1][1] == 'n' && argv[1][2] == '\0')
40 | 			flags |= MDB_NOSUBDIR;
41 | 		else if (argv[1][1] == 'v' && argv[1][2] == '\0')
42 | 			flags |= MDB_PREVSNAPSHOT;
43 | 		else if (argv[1][1] == 'c' && argv[1][2] == '\0')
44 | 			cpflags |= MDB_CP_COMPACT;
45 | 		else if (argv[1][1] == 'V' && argv[1][2] == '\0') {
46 | 			printf("%s\n", MDB_VERSION_STRING);
47 | 			exit(0);
48 | 		} else
49 | 			argc = 0;
50 | 	}
51 |
52 | 	if (argc<2 || argc>3) {
53 | 		fprintf(stderr, "usage: %s [-V] [-c] [-n] [-v] srcpath [dstpath]\n", progname);
54 | 		exit(EXIT_FAILURE);
55 | 	}
56 |
57 | #ifdef SIGPIPE
58 | 	signal(SIGPIPE, sighandle);
59 | #endif
60 | #ifdef SIGHUP
61 | 	signal(SIGHUP, sighandle);
62 | #endif
63 | 	signal(SIGINT, sighandle);
64 | 	signal(SIGTERM, sighandle);
65 |
66 | 	act = "opening environment";
67 | 	rc = mdb_env_create(&env);
68 | 	if (rc == MDB_SUCCESS) {
69 | 		rc = mdb_env_open(env, argv[1], flags, 0600);
70 | 	}
71 | 	if (rc == MDB_SUCCESS) {
72 | 		act = "copying";
73 | 		if (argc == 2)
74 | 			rc = mdb_env_copyfd2(env, MDB_STDOUT, cpflags);
75 | 		else
76 | 			rc = mdb_env_copy2(env, argv[2], cpflags);
77 | 	}
78 | 	if (rc)
79 | 		fprintf(stderr, "%s: %s failed, error %d (%s)\n",
80 | 			progname, act, rc, mdb_strerror(rc));
81 | 	mdb_env_close(env);
82 |
83 | 	return rc ? EXIT_FAILURE : EXIT_SUCCESS;
84 | }
85 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_drop.1:
--------------------------------------------------------------------------------
 1 | .TH MDB_DROP 1 "2017/11/19" "LMDB 0.9.70"
 2 | .\" Copyright 2014-2021 Howard Chu, Symas Corp. All Rights Reserved.
 3 | .\" Copying restrictions apply.  See COPYRIGHT/LICENSE.
 4 | .SH NAME
 5 | mdb_drop \- LMDB database delete tool
 6 | .SH SYNOPSIS
 7 | .B mdb_drop
 8 | [\c
 9 | .BR \-V ]
10 | [\c
11 | .BR \-n ]
12 | [\c
13 | .BR \-d ]
14 | [\c
15 | .BI \-s \ subdb\fR]
16 | .BR \ envpath
17 | .SH DESCRIPTION
18 | The
19 | .B mdb_drop
20 | utility empties or deletes a database in the specified
21 | environment.
22 | .SH OPTIONS
23 | .TP
24 | .BR \-V
25 | Write the library version number to the standard output, and exit.
26 | .TP
27 | .BR \-n
28 | Operate on an LMDB database which does not use subdirectories.
29 | .TP
30 | .BR \-d
31 | Delete the specified database, don't just empty it.
32 | .TP
33 | .BR \-s \ subdb
34 | Operate on a specific subdatabase. If no database is specified, only the main database is dropped.
35 | .SH DIAGNOSTICS
36 | Exit status is zero if no errors occur.
37 | Errors result in a non-zero exit status and
38 | a diagnostic message being written to standard error.
39 | .SH AUTHOR
40 | Howard Chu of Symas Corporation <http://www.symas.com>
41 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_drop.c:
--------------------------------------------------------------------------------
  1 | /* mdb_drop.c - memory-mapped database delete tool */
  2 | /*
  3 |  * Copyright 2016-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 | #include <stdio.h>
 15 | #include <errno.h>
 16 | #include <stdlib.h>
 17 | #include <string.h>
 18 | #include <ctype.h>
 19 | #include <unistd.h>
 20 | #include <signal.h>
 21 | #include "lmdb.h"
 22 |
 23 | static volatile sig_atomic_t gotsig;
 24 |
 25 | static void dumpsig( int sig )
 26 | {
 27 | 	gotsig=1;
 28 | }
 29 |
 30 | static void usage(char *prog)
 31 | {
 32 | 	fprintf(stderr, "usage: %s [-V] [-n] [-d] [-s subdb] dbpath\n", prog);
 33 | 	exit(EXIT_FAILURE);
 34 | }
 35 |
 36 | int main(int argc, char *argv[])
 37 | {
 38 | 	int i, rc;
 39 | 	MDB_env *env;
 40 | 	MDB_txn *txn;
 41 | 	MDB_dbi dbi;
 42 | 	char *prog = argv[0];
 43 | 	char *envname;
 44 | 	char *subname = NULL;
 45 | 	int envflags = 0, delete = 0;
 46 |
 47 | 	if (argc < 2) {
 48 | 		usage(prog);
 49 | 	}
 50 |
 51 | 	/* -d: delete the db, don't just empty it
 52 | 	 * -s: drop the named subDB
 53 | 	 * -n: use NOSUBDIR flag on env_open
 54 | 	 * -V: print version and exit
 55 | 	 * (default) empty the main DB
 56 | 	 */
 57 | 	while ((i = getopt(argc, argv, "dns:V")) != EOF) {
 58 | 		switch(i) {
 59 | 		case 'V':
 60 | 			printf("%s\n", MDB_VERSION_STRING);
 61 | 			exit(0);
 62 | 			break;
 63 | 		case 'd':
 64 | 			delete = 1;
 65 | 			break;
 66 | 		case 'n':
 67 | 			envflags |= MDB_NOSUBDIR;
 68 | 			break;
 69 | 		case 's':
 70 | 			subname = optarg;
 71 | 			break;
 72 | 		default:
 73 | 			usage(prog);
 74 | 		}
 75 | 	}
 76 |
 77 | 	if (optind != argc - 1)
 78 | 		usage(prog);
 79 |
 80 | #ifdef SIGPIPE
 81 | 	signal(SIGPIPE, dumpsig);
 82 | #endif
 83 | #ifdef SIGHUP
 84 | 	signal(SIGHUP, dumpsig);
 85 | #endif
 86 | 	signal(SIGINT, dumpsig);
 87 | 	signal(SIGTERM, dumpsig);
 88 |
 89 | 	envname = argv[optind];
 90 | 	rc = mdb_env_create(&env);
 91 | 	if (rc) {
 92 | 		fprintf(stderr, "mdb_env_create failed, error %d %s\n", rc, mdb_strerror(rc));
 93 | 		return EXIT_FAILURE;
 94 | 	}
 95 |
 96 | 	mdb_env_set_maxdbs(env, 2);
 97 |
 98 | 	rc = mdb_env_open(env, envname, envflags, 0664);
 99 | 	if (rc) {
100 | 		fprintf(stderr, "mdb_env_open failed, error %d %s\n", rc, mdb_strerror(rc));
101 | 		goto env_close;
102 | 	}
103 |
104 | 	rc = mdb_txn_begin(env, NULL, 0, &txn);
105 | 	if (rc) {
106 | 		fprintf(stderr, "mdb_txn_begin failed, error %d %s\n", rc, mdb_strerror(rc));
107 | 		goto env_close;
108 | 	}
109 |
110 | 	rc = mdb_open(txn, subname, 0, &dbi);
111 | 	if (rc) {
112 | 		fprintf(stderr, "mdb_open failed, error %d %s\n", rc, mdb_strerror(rc));
113 | 		goto txn_abort;
114 | 	}
115 |
116 | 	rc = mdb_drop(txn, dbi, delete);
117 | 	if (rc) {
118 | 		fprintf(stderr, "mdb_drop failed, error %d %s\n", rc, mdb_strerror(rc));
119 | 		goto txn_abort;
120 | 	}
121 | 	rc = mdb_txn_commit(txn);
122 | 	if (rc) {
123 | 		fprintf(stderr, "mdb_txn_commit failed, error %d %s\n", rc, mdb_strerror(rc));
124 | 		goto txn_abort;
125 | 	}
126 | 	txn = NULL;
127 |
128 | txn_abort:
129 | 	if (txn)
130 | 		mdb_txn_abort(txn);
131 | env_close:
132 | 	mdb_env_close(env);
133 |
134 | 	return rc ? EXIT_FAILURE : EXIT_SUCCESS;
135 | }
136 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_dump.1:
--------------------------------------------------------------------------------
 1 | .TH MDB_DUMP 1 "2017/07/31" "LMDB 0.9.70"
 2 | .\" Copyright 2014-2021 Howard Chu, Symas Corp. All Rights Reserved.
 3 | .\" Copying restrictions apply.  See COPYRIGHT/LICENSE.
 4 | .SH NAME
 5 | mdb_dump \- LMDB environment export tool
 6 | .SH SYNOPSIS
 7 | .B mdb_dump
 8 | [\c
 9 | .BR \-V ]
10 | [\c
11 | .BI \-f \ file\fR]
12 | [\c
13 | .BR \-l ]
14 | [\c
15 | .BR \-n ]
16 | [\c
17 | .BR \-v ]
18 | [\c
19 | .BR \-p ]
20 | [\c
21 | .BR \-a \ |
22 | .BI \-s \ subdb\fR]
23 | .BR \ envpath
24 | .SH DESCRIPTION
25 | The
26 | .B mdb_dump
27 | utility reads a database and writes its contents to the
28 | standard output using a portable flat-text format
29 | understood by the
30 | .BR mdb_load (1)
31 | utility.
32 | .SH OPTIONS
33 | .TP
34 | .BR \-V
35 | Write the library version number to the standard output, and exit.
36 | .TP
37 | .BR \-f \ file
38 | Write to the specified file instead of to the standard output.
39 | .TP
40 | .BR \-l
41 | List the databases stored in the environment. Just the
42 | names will be listed, no data will be output.
43 | .TP
44 | .BR \-n
45 | Dump an LMDB database which does not use subdirectories.
46 | .TP
47 | .BR \-v
48 | Use the previous environment state instead of the latest state.
49 | This may be useful if the latest state has been corrupted.
50 | .TP
51 | .BR \-p
52 | If characters in either the key or data items are printing characters (as
53 | defined by isprint(3)), output them directly. This option permits users to
54 | use standard text editors and tools to modify the contents of databases.
55 |
56 | Note: different systems may have different notions about what characters
57 | are considered printing characters, and databases dumped in this manner may
58 | be less portable to external systems.
59 | .TP
60 | .BR \-a
61 | Dump all of the subdatabases in the environment.
62 | .TP
63 | .BR \-s \ subdb
64 | Dump a specific subdatabase. If no database is specified, only the main database is dumped.
65 | .SH DIAGNOSTICS
66 | Exit status is zero if no errors occur.
67 | Errors result in a non-zero exit status and
68 | a diagnostic message being written to standard error.
69 |
70 | Dumping databases that use user-defined comparison functions will output
71 | records with the ordering imposed by those comparison functions. If
72 | .B mdb_load
73 | is invoked without including the
74 | .B -a
75 | option when reloading those records, the new databases will likely be
76 | damaged beyond repair, permitting neither record storage nor retrieval.
77 |
78 | .SH "SEE ALSO"
79 | .BR mdb_load (1)
80 | .SH AUTHOR
81 | Howard Chu of Symas Corporation <http://www.symas.com>
82 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_dump.c:
--------------------------------------------------------------------------------
  1 | /* mdb_dump.c - memory-mapped database dump tool */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 | #include <stdio.h>
 15 | #include <errno.h>
 16 | #include <stdlib.h>
 17 | #include <string.h>
 18 | #include <ctype.h>
 19 | #include <unistd.h>
 20 | #include <signal.h>
 21 | #include "lmdb.h"
 22 |
 23 | #define Yu	MDB_PRIy(u)
 24 |
 25 | #define PRINT	1
 26 | static int mode;
 27 |
 28 | typedef struct flagbit {
 29 | 	int bit;
 30 | 	char *name;
 31 | } flagbit;
 32 |
 33 | flagbit dbflags[] = {
 34 | 	{ MDB_REVERSEKEY, "reversekey" },
 35 | 	{ MDB_DUPSORT, "dupsort" },
 36 | 	{ MDB_INTEGERKEY, "integerkey" },
 37 | 	{ MDB_DUPFIXED, "dupfixed" },
 38 | 	{ MDB_INTEGERDUP, "integerdup" },
 39 | 	{ MDB_REVERSEDUP, "reversedup" },
 40 | 	{ 0, NULL }
 41 | };
 42 |
 43 | static volatile sig_atomic_t gotsig;
 44 |
 45 | static void dumpsig( int sig )
 46 | {
 47 | 	gotsig=1;
 48 | }
 49 |
 50 | static const char hexc[] = "0123456789abcdef";
 51 |
 52 | static void hex(unsigned char c)
 53 | {
 54 | 	putchar(hexc[c >> 4]);
 55 | 	putchar(hexc[c & 0xf]);
 56 | }
 57 |
 58 | static void text(MDB_val *v)
 59 | {
 60 | 	unsigned char *c, *end;
 61 |
 62 | 	putchar(' ');
 63 | 	c = v->mv_data;
 64 | 	end = c + v->mv_size;
 65 | 	while (c < end) {
 66 | 		if (isprint(*c)) {
 67 | 			if (*c == '\\')
 68 | 				putchar('\\');
 69 | 			putchar(*c);
 70 | 		} else {
 71 | 			putchar('\\');
 72 | 			hex(*c);
 73 | 		}
 74 | 		c++;
 75 | 	}
 76 | 	putchar('\n');
 77 | }
 78 |
 79 | static void byte(MDB_val *v)
 80 | {
 81 | 	unsigned char *c, *end;
 82 |
 83 | 	putchar(' ');
 84 | 	c = v->mv_data;
 85 | 	end = c + v->mv_size;
 86 | 	while (c < end) {
 87 | 		hex(*c++);
 88 | 	}
 89 | 	putchar('\n');
 90 | }
 91 |
 92 | /* Dump in BDB-compatible format */
 93 | static int dumpit(MDB_txn *txn, MDB_dbi dbi, char *name)
 94 | {
 95 | 	MDB_cursor *mc;
 96 | 	MDB_stat ms;
 97 | 	MDB_val key, data;
 98 | 	MDB_envinfo info;
 99 | 	unsigned int flags;
100 | 	int rc, i;
101 |
102 | 	rc = mdb_dbi_flags(txn, dbi, &flags);
103 | 	if (rc) return rc;
104 |
105 | 	rc = mdb_stat(txn, dbi, &ms);
106 | 	if (rc) return rc;
107 |
108 | 	rc = mdb_env_info(mdb_txn_env(txn), &info);
109 | 	if (rc) return rc;
110 |
111 | 	printf("VERSION=3\n");
112 | 	printf("format=%s\n", mode & PRINT ? "print" : "bytevalue");
113 | 	if (name)
114 | 		printf("database=%s\n", name);
115 | 	printf("type=btree\n");
116 | 	printf("mapsize=%"Yu"\n", info.me_mapsize);
117 | 	if (info.me_mapaddr)
118 | 		printf("mapaddr=%p\n", info.me_mapaddr);
119 | 	printf("maxreaders=%u\n", info.me_maxreaders);
120 |
121 | 	if (flags & MDB_DUPSORT)
122 | 		printf("duplicates=1\n");
123 |
124 | 	for (i=0; dbflags[i].bit; i++)
125 | 		if (flags & dbflags[i].bit)
126 | 			printf("%s=1\n", dbflags[i].name);
127 |
128 | 	printf("db_pagesize=%d\n", ms.ms_psize);
129 | 	printf("HEADER=END\n");
130 |
131 | 	rc = mdb_cursor_open(txn, dbi, &mc);
132 | 	if (rc) return rc;
133 |
134 | 	while ((rc = mdb_cursor_get(mc, &key, &data, MDB_NEXT) == MDB_SUCCESS)) {
135 | 		if (gotsig) {
136 | 			rc = EINTR;
137 | 			break;
138 | 		}
139 | 		if (mode & PRINT) {
140 | 			text(&key);
141 | 			text(&data);
142 | 		} else {
143 | 			byte(&key);
144 | 			byte(&data);
145 | 		}
146 | 	}
147 | 	printf("DATA=END\n");
148 | 	if (rc == MDB_NOTFOUND)
149 | 		rc = MDB_SUCCESS;
150 |
151 | 	return rc;
152 | }
153 |
154 | static void usage(char *prog)
155 | {
156 | 	fprintf(stderr, "usage: %s [-V] [-f output] [-l] [-n] [-p] [-v] [-a|-s subdb] dbpath\n", prog);
157 | 	exit(EXIT_FAILURE);
158 | }
159 |
160 | int main(int argc, char *argv[])
161 | {
162 | 	int i, rc;
163 | 	MDB_env *env;
164 | 	MDB_txn *txn;
165 | 	MDB_dbi dbi;
166 | 	char *prog = argv[0];
167 | 	char *envname;
168 | 	char *subname = NULL;
169 | 	int alldbs = 0, envflags = 0, list = 0;
170 |
171 | 	if (argc < 2) {
172 | 		usage(prog);
173 | 	}
174 |
175 | 	/* -a: dump main DB and all subDBs
176 | 	 * -s: dump only the named subDB
177 | 	 * -n: use NOSUBDIR flag on env_open
178 | 	 * -p: use printable characters
179 | 	 * -f: write to file instead of stdout
180 | 	 * -v: use previous snapshot
181 | 	 * -V: print version and exit
182 | 	 * (default) dump only the main DB
183 | 	 */
184 | 	while ((i = getopt(argc, argv, "af:lnps:vV")) != EOF) {
185 | 		switch(i) {
186 | 		case 'V':
187 | 			printf("%s\n", MDB_VERSION_STRING);
188 | 			exit(0);
189 | 			break;
190 | 		case 'l':
191 | 			list = 1;
192 | 			/*FALLTHROUGH*/
193 | 		case 'a':
194 | 			if (subname)
195 | 				usage(prog);
196 | 			alldbs++;
197 | 			break;
198 | 		case 'f':
199 | 			if (freopen(optarg, "w", stdout) == NULL) {
200 | 				fprintf(stderr, "%s: %s: reopen: %s\n",
201 | 					prog, optarg, strerror(errno));
202 | 				exit(EXIT_FAILURE);
203 | 			}
204 | 			break;
205 | 		case 'n':
206 | 			envflags |= MDB_NOSUBDIR;
207 | 			break;
208 | 		case 'v':
209 | 			envflags |= MDB_PREVSNAPSHOT;
210 | 			break;
211 | 		case 'p':
212 | 			mode |= PRINT;
213 | 			break;
214 | 		case 's':
215 | 			if (alldbs)
216 | 				usage(prog);
217 | 			subname = optarg;
218 | 			break;
219 | 		default:
220 | 			usage(prog);
221 | 		}
222 | 	}
223 |
224 | 	if (optind != argc - 1)
225 | 		usage(prog);
226 |
227 | #ifdef SIGPIPE
228 | 	signal(SIGPIPE, dumpsig);
229 | #endif
230 | #ifdef SIGHUP
231 | 	signal(SIGHUP, dumpsig);
232 | #endif
233 | 	signal(SIGINT, dumpsig);
234 | 	signal(SIGTERM, dumpsig);
235 |
236 | 	envname = argv[optind];
237 | 	rc = mdb_env_create(&env);
238 | 	if (rc) {
239 | 		fprintf(stderr, "mdb_env_create failed, error %d %s\n", rc, mdb_strerror(rc));
240 | 		return EXIT_FAILURE;
241 | 	}
242 |
243 | 	if (alldbs || subname) {
244 | 		mdb_env_set_maxdbs(env, 2);
245 | 	}
246 |
247 | 	rc = mdb_env_open(env, envname, envflags | MDB_RDONLY, 0664);
248 | 	if (rc) {
249 | 		fprintf(stderr, "mdb_env_open failed, error %d %s\n", rc, mdb_strerror(rc));
250 | 		goto env_close;
251 | 	}
252 |
253 | 	rc = mdb_txn_begin(env, NULL, MDB_RDONLY, &txn);
254 | 	if (rc) {
255 | 		fprintf(stderr, "mdb_txn_begin failed, error %d %s\n", rc, mdb_strerror(rc));
256 | 		goto env_close;
257 | 	}
258 |
259 | 	rc = mdb_open(txn, subname, 0, &dbi);
260 | 	if (rc) {
261 | 		fprintf(stderr, "mdb_open failed, error %d %s\n", rc, mdb_strerror(rc));
262 | 		goto txn_abort;
263 | 	}
264 |
265 | 	if (alldbs) {
266 | 		MDB_cursor *cursor;
267 | 		MDB_val key;
268 | 		int count = 0;
269 |
270 | 		rc = mdb_cursor_open(txn, dbi, &cursor);
271 | 		if (rc) {
272 | 			fprintf(stderr, "mdb_cursor_open failed, error %d %s\n", rc, mdb_strerror(rc));
273 | 			goto txn_abort;
274 | 		}
275 | 		while ((rc = mdb_cursor_get(cursor, &key, NULL, MDB_NEXT_NODUP)) == 0) {
276 | 			char *str;
277 | 			MDB_dbi db2;
278 | 			if (memchr(key.mv_data, '\0', key.mv_size))
279 | 				continue;
280 | 			count++;
281 | 			str = malloc(key.mv_size+1);
282 | 			memcpy(str, key.mv_data, key.mv_size);
283 | 			str[key.mv_size] = '\0';
284 | 			rc = mdb_open(txn, str, 0, &db2);
285 | 			if (rc == MDB_SUCCESS) {
286 | 				if (list) {
287 | 					printf("%s\n", str);
288 | 					list++;
289 | 				} else {
290 | 					rc = dumpit(txn, db2, str);
291 | 					if (rc)
292 | 						break;
293 | 				}
294 | 				mdb_close(env, db2);
295 | 			}
296 | 			free(str);
297 | 			if (rc) continue;
298 | 		}
299 | 		mdb_cursor_close(cursor);
300 | 		if (!count) {
301 | 			fprintf(stderr, "%s: %s does not contain multiple databases\n", prog, envname);
302 | 			rc = MDB_NOTFOUND;
303 | 		} else if (rc == MDB_NOTFOUND) {
304 | 			rc = MDB_SUCCESS;
305 | 		}
306 | 	} else {
307 | 		rc = dumpit(txn, dbi, subname);
308 | 	}
309 | 	if (rc && rc != MDB_NOTFOUND)
310 | 		fprintf(stderr, "%s: %s: %s\n", prog, envname, mdb_strerror(rc));
311 |
312 | 	mdb_close(env, dbi);
313 | txn_abort:
314 | 	mdb_txn_abort(txn);
315 | env_close:
316 | 	mdb_env_close(env);
317 |
318 | 	return rc ? EXIT_FAILURE : EXIT_SUCCESS;
319 | }
320 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_load.1:
--------------------------------------------------------------------------------
 1 | .TH MDB_LOAD 1 "2015/09/30" "LMDB 0.9.17"
 2 | .\" Copyright 2014-2021 Howard Chu, Symas Corp. All Rights Reserved.
 3 | .\" Copying restrictions apply.  See COPYRIGHT/LICENSE.
 4 | .SH NAME
 5 | mdb_load \- LMDB environment import tool
 6 | .SH SYNOPSIS
 7 | .B mdb_load
 8 | [\c
 9 | .BR \-V ]
10 | [\c
11 | .BR \-a ]
12 | [\c
13 | .BI \-f \ file\fR]
14 | [\c
15 | .BR \-n ]
16 | [\c
17 | .BI \-s \ subdb\fR]
18 | [\c
19 | .BR \-N ]
20 | [\c
21 | .BR \-Q ]
22 | [\c
23 | .BR \-T ]
24 | .BR \ envpath
25 | .SH DESCRIPTION
26 | The
27 | .B mdb_load
28 | utility reads from the standard input and loads it into the
29 | LMDB environment
30 | .BR envpath .
31 |
32 | The input to
33 | .B mdb_load
34 | must be in the output format specified by the
35 | .BR mdb_dump (1)
36 | utility or as specified by the
37 | .B -T
38 | option below.
39 | .SH OPTIONS
40 | .TP
41 | .BR \-V
42 | Write the library version number to the standard output, and exit.
43 | .TP
44 | .BR \-a
45 | Append all records in the order they appear in the input. The input is assumed to already be
46 | in correctly sorted order and no sorting or checking for redundant values will be performed.
47 | This option must be used to reload data that was produced by running
48 | .B mdb_dump
49 | on a database that uses custom compare functions.
50 | .TP
51 | .BR \-f \ file
52 | Read from the specified file instead of from the standard input.
53 | .TP
54 | .BR \-n
55 | Load an LMDB database which does not use subdirectories.
56 | .TP
57 | .BR \-s \ subdb
58 | Load a specific subdatabase. If no database is specified, data is loaded into the main database.
59 | .TP
60 | .BR \-N
61 | Don't overwrite existing records when loading into an already existing database; just skip them.
62 | .TP
63 | .BR \-Q
64 | Quick mode, uses MDB_NOSYNC for faster loading.  Forces sync with mdb_env_sync() before exiting.
65 | .TP
66 | .BR \-T
67 | Load data from simple text files. The input must be paired lines of text, where the first
68 | line of the pair is the key item, and the second line of the pair is its corresponding
69 | data item.
70 |
71 | A simple escape mechanism, where newline and backslash (\\) characters are special, is
72 | applied to the text input. Newline characters are interpreted as record separators.
73 | Backslash characters in the text will be interpreted in one of two ways: If the backslash
74 | character precedes another backslash character, the pair will be interpreted as a literal
75 | backslash. If the backslash character precedes any other character, the two characters
76 | following the backslash will be interpreted as a hexadecimal specification of a single
77 | character; for example, \\0a is a newline character in the ASCII character set.
78 |
79 | For this reason, any backslash or newline characters that naturally occur in the text
80 | input must be escaped to avoid misinterpretation by
81 | .BR mdb_load .
82 |
83 | .SH DIAGNOSTICS
84 | Exit status is zero if no errors occur.
85 | Errors result in a non-zero exit status and
86 | a diagnostic message being written to standard error.
87 |
88 | .SH "SEE ALSO"
89 | .BR mdb_dump (1)
90 | .SH AUTHOR
91 | Howard Chu of Symas Corporation <http://www.symas.com>
92 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_load.c:
--------------------------------------------------------------------------------
  1 | /* mdb_load.c - memory-mapped database load tool */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 | #include <stdio.h>
 15 | #include <stdlib.h>
 16 | #include <errno.h>
 17 | #include <string.h>
 18 | #include <ctype.h>
 19 | #include <unistd.h>
 20 | #include "lmdb.h"
 21 |
 22 | #define PRINT	1
 23 | #define NOHDR	2
 24 | static int mode;
 25 |
 26 | static char *subname = NULL;
 27 |
 28 | static mdb_size_t lineno;
 29 | static int version;
 30 |
 31 | static int flags;
 32 |
 33 | static char *prog;
 34 |
 35 | static int Eof;
 36 |
 37 | static MDB_envinfo info;
 38 |
 39 | static MDB_val kbuf, dbuf;
 40 | static MDB_val k0buf;
 41 |
 42 | #define Yu	MDB_PRIy(u)
 43 |
 44 | #define STRLENOF(s)	(sizeof(s)-1)
 45 |
 46 | typedef struct flagbit {
 47 | 	int bit;
 48 | 	char *name;
 49 | 	int len;
 50 | } flagbit;
 51 |
 52 | #define S(s)	s, STRLENOF(s)
 53 |
 54 | flagbit dbflags[] = {
 55 | 	{ MDB_REVERSEKEY, S("reversekey") },
 56 | 	{ MDB_DUPSORT, S("dupsort") },
 57 | 	{ MDB_INTEGERKEY, S("integerkey") },
 58 | 	{ MDB_DUPFIXED, S("dupfixed") },
 59 | 	{ MDB_INTEGERDUP, S("integerdup") },
 60 | 	{ MDB_REVERSEDUP, S("reversedup") },
 61 | 	{ 0, NULL, 0 }
 62 | };
 63 |
 64 | static void readhdr(void)
 65 | {
 66 | 	char *ptr;
 67 |
 68 | 	flags = 0;
 69 | 	while (fgets(dbuf.mv_data, dbuf.mv_size, stdin) != NULL) {
 70 | 		lineno++;
 71 | 		if (!strncmp(dbuf.mv_data, "VERSION=", STRLENOF("VERSION="))) {
 72 | 			version=atoi((char *)dbuf.mv_data+STRLENOF("VERSION="));
 73 | 			if (version > 3) {
 74 | 				fprintf(stderr, "%s: line %"Yu": unsupported VERSION %d\n",
 75 | 					prog, lineno, version);
 76 | 				exit(EXIT_FAILURE);
 77 | 			}
 78 | 		} else if (!strncmp(dbuf.mv_data, "HEADER=END", STRLENOF("HEADER=END"))) {
 79 | 			break;
 80 | 		} else if (!strncmp(dbuf.mv_data, "format=", STRLENOF("format="))) {
 81 | 			if (!strncmp((char *)dbuf.mv_data+STRLENOF("FORMAT="), "print", STRLENOF("print")))
 82 | 				mode |= PRINT;
 83 | 			else if (strncmp((char *)dbuf.mv_data+STRLENOF("FORMAT="), "bytevalue", STRLENOF("bytevalue"))) {
 84 | 				fprintf(stderr, "%s: line %"Yu": unsupported FORMAT %s\n",
 85 | 					prog, lineno, (char *)dbuf.mv_data+STRLENOF("FORMAT="));
 86 | 				exit(EXIT_FAILURE);
 87 | 			}
 88 | 		} else if (!strncmp(dbuf.mv_data, "database=", STRLENOF("database="))) {
 89 | 			ptr = memchr(dbuf.mv_data, '\n', dbuf.mv_size);
 90 | 			if (ptr) *ptr = '\0';
 91 | 			if (subname) free(subname);
 92 | 			subname = strdup((char *)dbuf.mv_data+STRLENOF("database="));
 93 | 		} else if (!strncmp(dbuf.mv_data, "type=", STRLENOF("type="))) {
 94 | 			if (strncmp((char *)dbuf.mv_data+STRLENOF("type="), "btree", STRLENOF("btree")))  {
 95 | 				fprintf(stderr, "%s: line %"Yu": unsupported type %s\n",
 96 | 					prog, lineno, (char *)dbuf.mv_data+STRLENOF("type="));
 97 | 				exit(EXIT_FAILURE);
 98 | 			}
 99 | 		} else if (!strncmp(dbuf.mv_data, "mapaddr=", STRLENOF("mapaddr="))) {
100 | 			int i;
101 | 			ptr = memchr(dbuf.mv_data, '\n', dbuf.mv_size);
102 | 			if (ptr) *ptr = '\0';
103 | 			i = sscanf((char *)dbuf.mv_data+STRLENOF("mapaddr="), "%p", &info.me_mapaddr);
104 | 			if (i != 1) {
105 | 				fprintf(stderr, "%s: line %"Yu": invalid mapaddr %s\n",
106 | 					prog, lineno, (char *)dbuf.mv_data+STRLENOF("mapaddr="));
107 | 				exit(EXIT_FAILURE);
108 | 			}
109 | 		} else if (!strncmp(dbuf.mv_data, "mapsize=", STRLENOF("mapsize="))) {
110 | 			int i;
111 | 			ptr = memchr(dbuf.mv_data, '\n', dbuf.mv_size);
112 | 			if (ptr) *ptr = '\0';
113 | 			i = sscanf((char *)dbuf.mv_data+STRLENOF("mapsize="),
114 | 				"%" MDB_SCNy(u), &info.me_mapsize);
115 | 			if (i != 1) {
116 | 				fprintf(stderr, "%s: line %"Yu": invalid mapsize %s\n",
117 | 					prog, lineno, (char *)dbuf.mv_data+STRLENOF("mapsize="));
118 | 				exit(EXIT_FAILURE);
119 | 			}
120 | 		} else if (!strncmp(dbuf.mv_data, "maxreaders=", STRLENOF("maxreaders="))) {
121 | 			int i;
122 | 			ptr = memchr(dbuf.mv_data, '\n', dbuf.mv_size);
123 | 			if (ptr) *ptr = '\0';
124 | 			i = sscanf((char *)dbuf.mv_data+STRLENOF("maxreaders="), "%u", &info.me_maxreaders);
125 | 			if (i != 1) {
126 | 				fprintf(stderr, "%s: line %"Yu": invalid maxreaders %s\n",
127 | 					prog, lineno, (char *)dbuf.mv_data+STRLENOF("maxreaders="));
128 | 				exit(EXIT_FAILURE);
129 | 			}
130 | 		} else {
131 | 			int i;
132 | 			for (i=0; dbflags[i].bit; i++) {
133 | 				if (!strncmp(dbuf.mv_data, dbflags[i].name, dbflags[i].len) &&
134 | 					((char *)dbuf.mv_data)[dbflags[i].len] == '=') {
135 | 					flags |= dbflags[i].bit;
136 | 					break;
137 | 				}
138 | 			}
139 | 			if (!dbflags[i].bit) {
140 | 				ptr = memchr(dbuf.mv_data, '=', dbuf.mv_size);
141 | 				if (!ptr) {
142 | 					fprintf(stderr, "%s: line %"Yu": unexpected format\n",
143 | 						prog, lineno);
144 | 					exit(EXIT_FAILURE);
145 | 				} else {
146 | 					*ptr = '\0';
147 | 					fprintf(stderr, "%s: line %"Yu": unrecognized keyword ignored: %s\n",
148 | 						prog, lineno, (char *)dbuf.mv_data);
149 | 				}
150 | 			}
151 | 		}
152 | 	}
153 | }
154 |
155 | static void badend(void)
156 | {
157 | 	fprintf(stderr, "%s: line %"Yu": unexpected end of input\n",
158 | 		prog, lineno);
159 | }
160 |
161 | static int unhex(unsigned char *c2)
162 | {
163 | 	int x, c;
164 | 	x = *c2++ & 0x4f;
165 | 	if (x & 0x40)
166 | 		x -= 55;
167 | 	c = x << 4;
168 | 	x = *c2 & 0x4f;
169 | 	if (x & 0x40)
170 | 		x -= 55;
171 | 	c |= x;
172 | 	return c;
173 | }
174 |
175 | static int readline(MDB_val *out, MDB_val *buf)
176 | {
177 | 	unsigned char *c1, *c2, *end;
178 | 	size_t len, l2;
179 | 	int c;
180 |
181 | 	if (!(mode & NOHDR)) {
182 | 		c = fgetc(stdin);
183 | 		if (c == EOF) {
184 | 			Eof = 1;
185 | 			return EOF;
186 | 		}
187 | 		if (c != ' ') {
188 | 			lineno++;
189 | 			if (fgets(buf->mv_data, buf->mv_size, stdin) == NULL) {
190 | badend:
191 | 				Eof = 1;
192 | 				badend();
193 | 				return EOF;
194 | 			}
195 | 			if (c == 'D' && !strncmp(buf->mv_data, "ATA=END", STRLENOF("ATA=END")))
196 | 				return EOF;
197 | 			goto badend;
198 | 		}
199 | 	}
200 | 	if (fgets(buf->mv_data, buf->mv_size, stdin) == NULL) {
201 | 		Eof = 1;
202 | 		return EOF;
203 | 	}
204 | 	lineno++;
205 |
206 | 	c1 = buf->mv_data;
207 | 	len = strlen((char *)c1);
208 | 	l2 = len;
209 |
210 | 	/* Is buffer too short? */
211 | 	while (c1[len-1] != '\n') {
212 | 		buf->mv_data = realloc(buf->mv_data, buf->mv_size*2);
213 | 		if (!buf->mv_data) {
214 | 			Eof = 1;
215 | 			fprintf(stderr, "%s: line %"Yu": out of memory, line too long\n",
216 | 				prog, lineno);
217 | 			return EOF;
218 | 		}
219 | 		c1 = buf->mv_data;
220 | 		c1 += l2;
221 | 		if (fgets((char *)c1, buf->mv_size+1, stdin) == NULL) {
222 | 			Eof = 1;
223 | 			badend();
224 | 			return EOF;
225 | 		}
226 | 		buf->mv_size *= 2;
227 | 		len = strlen((char *)c1);
228 | 		l2 += len;
229 | 	}
230 | 	c1 = c2 = buf->mv_data;
231 | 	len = l2;
232 | 	c1[--len] = '\0';
233 | 	end = c1 + len;
234 |
235 | 	if (mode & PRINT) {
236 | 		while (c2 < end) {
237 | 			if (*c2 == '\\') {
238 | 				if (c2[1] == '\\') {
239 | 					*c1++ = *c2;
240 | 				} else {
241 | 					if (c2+3 > end || !isxdigit(c2[1]) || !isxdigit(c2[2])) {
242 | 						Eof = 1;
243 | 						badend();
244 | 						return EOF;
245 | 					}
246 | 					*c1++ = unhex(++c2);
247 | 				}
248 | 				c2 += 2;
249 | 			} else {
250 | 				/* copies are redundant when no escapes were used */
251 | 				*c1++ = *c2++;
252 | 			}
253 | 		}
254 | 	} else {
255 | 		/* odd length not allowed */
256 | 		if (len & 1) {
257 | 			Eof = 1;
258 | 			badend();
259 | 			return EOF;
260 | 		}
261 | 		while (c2 < end) {
262 | 			if (!isxdigit(*c2) || !isxdigit(c2[1])) {
263 | 				Eof = 1;
264 | 				badend();
265 | 				return EOF;
266 | 			}
267 | 			*c1++ = unhex(c2);
268 | 			c2 += 2;
269 | 		}
270 | 	}
271 | 	c2 = out->mv_data = buf->mv_data;
272 | 	out->mv_size = c1 - c2;
273 |
274 | 	return 0;
275 | }
276 |
277 | static void usage(void)
278 | {
279 | 	fprintf(stderr, "usage: %s [-V] [-a] [-f input] [-n] [-s name] [-N] [-T] dbpath\n", prog);
280 | 	exit(EXIT_FAILURE);
281 | }
282 |
283 | static int greater(const MDB_val *a, const MDB_val *b)
284 | {
285 | 	return 1;
286 | }
287 |
288 | int main(int argc, char *argv[])
289 | {
290 | 	int i, rc;
291 | 	MDB_env *env;
292 | 	MDB_txn *txn;
293 | 	MDB_cursor *mc;
294 | 	MDB_dbi dbi;
295 | 	char *envname;
296 | 	int envflags = MDB_NOSYNC, putflags = 0;
297 | 	int dohdr = 0, append = 0;
298 | 	MDB_val prevk;
299 |
300 | 	prog = argv[0];
301 |
302 | 	if (argc < 2) {
303 | 		usage();
304 | 	}
305 |
306 | 	/* -a: append records in input order
307 | 	 * -f: load file instead of stdin
308 | 	 * -n: use NOSUBDIR flag on env_open
309 | 	 * -s: load into named subDB
310 | 	 * -N: use NOOVERWRITE on puts
311 | 	 * -Q: quick mode using NOSYNC
312 | 	 * -T: read plaintext
313 | 	 * -V: print version and exit
314 | 	 */
315 | 	while ((i = getopt(argc, argv, "af:ns:NQTV")) != EOF) {
316 | 		switch(i) {
317 | 		case 'V':
318 | 			printf("%s\n", MDB_VERSION_STRING);
319 | 			exit(0);
320 | 			break;
321 | 		case 'a':
322 | 			append = 1;
323 | 			break;
324 | 		case 'f':
325 | 			if (freopen(optarg, "r", stdin) == NULL) {
326 | 				fprintf(stderr, "%s: %s: reopen: %s\n",
327 | 					prog, optarg, strerror(errno));
328 | 				exit(EXIT_FAILURE);
329 | 			}
330 | 			break;
331 | 		case 'n':
332 | 			envflags |= MDB_NOSUBDIR;
333 | 			break;
334 | 		case 's':
335 | 			subname = strdup(optarg);
336 | 			break;
337 | 		case 'N':
338 | 			putflags = MDB_NOOVERWRITE|MDB_NODUPDATA;
339 | 			break;
340 | 		case 'Q':
341 | 			envflags |= MDB_NOSYNC;
342 | 			break;
343 | 		case 'T':
344 | 			mode |= NOHDR | PRINT;
345 | 			break;
346 | 		default:
347 | 			usage();
348 | 		}
349 | 	}
350 |
351 | 	if (optind != argc - 1)
352 | 		usage();
353 |
354 | 	dbuf.mv_size = 4096;
355 | 	dbuf.mv_data = malloc(dbuf.mv_size);
356 |
357 | 	if (!(mode & NOHDR))
358 | 		readhdr();
359 |
360 | 	envname = argv[optind];
361 | 	rc = mdb_env_create(&env);
362 | 	if (rc) {
363 | 		fprintf(stderr, "mdb_env_create failed, error %d %s\n", rc, mdb_strerror(rc));
364 | 		return EXIT_FAILURE;
365 | 	}
366 |
367 | 	mdb_env_set_maxdbs(env, 2);
368 |
369 | 	if (info.me_maxreaders)
370 | 		mdb_env_set_maxreaders(env, info.me_maxreaders);
371 |
372 | 	if (info.me_mapsize)
373 | 		mdb_env_set_mapsize(env, info.me_mapsize);
374 |
375 | 	if (info.me_mapaddr)
376 | 		envflags |= MDB_FIXEDMAP;
377 |
378 | 	rc = mdb_env_open(env, envname, envflags, 0664);
379 | 	if (rc) {
380 | 		fprintf(stderr, "mdb_env_open failed, error %d %s\n", rc, mdb_strerror(rc));
381 | 		goto env_close;
382 | 	}
383 |
384 | 	kbuf.mv_size = mdb_env_get_maxkeysize(env) * 2 + 2;
385 | 	kbuf.mv_data = malloc(kbuf.mv_size * 2);
386 | 	k0buf.mv_size = kbuf.mv_size;
387 | 	k0buf.mv_data = (char *)kbuf.mv_data + kbuf.mv_size;
388 | 	prevk.mv_data = k0buf.mv_data;
389 |
390 | 	while(!Eof) {
391 | 		MDB_val key, data;
392 | 		int batch = 0;
393 | 		int appflag;
394 |
395 | 		if (!dohdr) {
396 | 			dohdr = 1;
397 | 		} else if (!(mode & NOHDR))
398 | 			readhdr();
399 |
400 | 		rc = mdb_txn_begin(env, NULL, 0, &txn);
401 | 		if (rc) {
402 | 			fprintf(stderr, "mdb_txn_begin failed, error %d %s\n", rc, mdb_strerror(rc));
403 | 			goto env_close;
404 | 		}
405 |
406 | 		rc = mdb_dbi_open(txn, subname, flags|MDB_CREATE, &dbi);
407 | 		if (rc) {
408 | 			fprintf(stderr, "mdb_dbi_open failed, error %d %s\n", rc, mdb_strerror(rc));
409 | 			goto txn_abort;
410 | 		}
411 | 		prevk.mv_size = 0;
412 | 		if (append) {
413 | 			mdb_set_compare(txn, dbi, greater);
414 | 			if (flags & MDB_DUPSORT)
415 | 				mdb_set_dupsort(txn, dbi, greater);
416 | 		}
417 |
418 | 		rc = mdb_cursor_open(txn, dbi, &mc);
419 | 		if (rc) {
420 | 			fprintf(stderr, "mdb_cursor_open failed, error %d %s\n", rc, mdb_strerror(rc));
421 | 			goto txn_abort;
422 | 		}
423 |
424 | 		while(1) {
425 | 			rc = readline(&key, &kbuf);
426 | 			if (rc)  /* rc == EOF */
427 | 				break;
428 |
429 | 			rc = readline(&data, &dbuf);
430 | 			if (rc) {
431 | 				fprintf(stderr, "%s: line %"Yu": failed to read key value\n", prog, lineno);
432 | 				goto txn_abort;
433 | 			}
434 |
435 | 			if (append) {
436 | 				appflag = MDB_APPEND;
437 | 				if (flags & MDB_DUPSORT) {
438 | 					if (prevk.mv_size == key.mv_size && !memcmp(prevk.mv_data, key.mv_data, key.mv_size))
439 | 						appflag = MDB_CURRENT|MDB_APPENDDUP;
440 | 					else {
441 | 						memcpy(prevk.mv_data, key.mv_data, key.mv_size);
442 | 						prevk.mv_size = key.mv_size;
443 | 					}
444 | 				}
445 | 			} else {
446 | 				appflag = 0;
447 | 			}
448 | 			rc = mdb_cursor_put(mc, &key, &data, putflags|appflag);
449 | 			if (rc == MDB_KEYEXIST && putflags)
450 | 				continue;
451 | 			if (rc) {
452 | 				fprintf(stderr, "%s: line %"Yu": mdb_cursor_put failed, error %d %s\n", prog, lineno, rc, mdb_strerror(rc));
453 | 				goto txn_abort;
454 | 			}
455 | 			batch++;
456 | 			if (batch == 100) {
457 | 				rc = mdb_txn_commit(txn);
458 | 				if (rc) {
459 | 					fprintf(stderr, "%s: line %"Yu": txn_commit: %s\n",
460 | 						prog, lineno, mdb_strerror(rc));
461 | 					goto env_close;
462 | 				}
463 | 				rc = mdb_txn_begin(env, NULL, 0, &txn);
464 | 				if (rc) {
465 | 					fprintf(stderr, "mdb_txn_begin failed, error %d %s\n", rc, mdb_strerror(rc));
466 | 					goto env_close;
467 | 				}
468 | 				rc = mdb_cursor_open(txn, dbi, &mc);
469 | 				if (rc) {
470 | 					fprintf(stderr, "mdb_cursor_open failed, error %d %s\n", rc, mdb_strerror(rc));
471 | 					goto txn_abort;
472 | 				}
473 | 				if (append) {
474 | 					MDB_val k, d;
475 | 					mdb_cursor_get(mc, &k, &d, MDB_LAST);
476 | 					memcpy(prevk.mv_data, k.mv_data, k.mv_size);
477 | 					prevk.mv_size = k.mv_size;
478 | 				}
479 | 				batch = 0;
480 | 			}
481 | 		}
482 | 		rc = mdb_txn_commit(txn);
483 | 		txn = NULL;
484 | 		if (rc) {
485 | 			fprintf(stderr, "%s: line %"Yu": txn_commit: %s\n",
486 | 				prog, lineno, mdb_strerror(rc));
487 | 			goto env_close;
488 | 		}
489 | 		if (envflags & MDB_NOSYNC) {
490 | 			rc = mdb_env_sync(env, 1);
491 | 			if (rc) {
492 | 				fprintf(stderr, "mdb_env_sync failed, error %d %s\n", rc, mdb_strerror(rc));
493 | 				goto env_close;
494 | 			}
495 | 		}
496 | 		mdb_dbi_close(env, dbi);
497 | 	}
498 |
499 | txn_abort:
500 | 	mdb_txn_abort(txn);
501 | env_close:
502 | 	mdb_env_close(env);
503 |
504 | 	return rc ? EXIT_FAILURE : EXIT_SUCCESS;
505 | }
506 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_stat.1:
--------------------------------------------------------------------------------
 1 | .TH MDB_STAT 1 "2017/07/31" "LMDB 0.9.70"
 2 | .\" Copyright 2012-2021 Howard Chu, Symas Corp. All Rights Reserved.
 3 | .\" Copying restrictions apply.  See COPYRIGHT/LICENSE.
 4 | .SH NAME
 5 | mdb_stat \- LMDB environment status tool
 6 | .SH SYNOPSIS
 7 | .B mdb_stat
 8 | [\c
 9 | .BR \-V ]
10 | [\c
11 | .BR \-e ]
12 | [\c
13 | .BR \-f [ f [ f ]]]
14 | [\c
15 | .BR \-n ]
16 | [\c
17 | .BR \-v ]
18 | [\c
19 | .BR \-r [ r ]]
20 | [\c
21 | .BR \-a \ |
22 | .BI \-s \ subdb\fR]
23 | .BR \ envpath
24 | .SH DESCRIPTION
25 | The
26 | .B mdb_stat
27 | utility displays the status of an LMDB environment.
28 | .SH OPTIONS
29 | .TP
30 | .BR \-V
31 | Write the library version number to the standard output, and exit.
32 | .TP
33 | .BR \-e
34 | Display information about the database environment.
35 | .TP
36 | .BR \-f
37 | Display information about the environment freelist.
38 | If \fB\-ff\fP is given, summarize each freelist entry.
39 | If \fB\-fff\fP is given, display the full list of page IDs in the freelist.
40 | .TP
41 | .BR \-n
42 | Display the status of an LMDB database which does not use subdirectories.
43 | .TP
44 | .BR \-v
45 | Use the previous environment state instead of the latest state.
46 | This may be useful if the latest state has been corrupted.
47 | .TP
48 | .BR \-r
49 | Display information about the environment reader table.
50 | Shows the process ID, thread ID, and transaction ID for each active
51 | reader slot. The process ID and transaction ID are in decimal, the
52 | thread ID is in hexadecimal. The transaction ID is displayed as "-"
53 | if the reader does not currently have a read transaction open.
54 | If \fB\-rr\fP is given, check for stale entries in the reader
55 | table and clear them. The reader table will be printed again
56 | after the check is performed.
57 | .TP
58 | .BR \-a
59 | Display the status of all of the subdatabases in the environment.
60 | .TP
61 | .BR \-s \ subdb
62 | Display the status of a specific subdatabase.
63 | .SH DIAGNOSTICS
64 | Exit status is zero if no errors occur.
65 | Errors result in a non-zero exit status and
66 | a diagnostic message being written to standard error.
67 | .SH "SEE ALSO"
68 | .BR mdb_copy (1)
69 | .SH AUTHOR
70 | Howard Chu of Symas Corporation <http://www.symas.com>
71 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mdb_stat.c:
--------------------------------------------------------------------------------
  1 | /* mdb_stat.c - memory-mapped database status tool */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 | #include <stdio.h>
 15 | #include <stdlib.h>
 16 | #include <string.h>
 17 | #include <unistd.h>
 18 | #include "lmdb.h"
 19 |
 20 | #define Z	MDB_FMT_Z
 21 | #define Yu	MDB_PRIy(u)
 22 |
 23 | static void prstat(MDB_stat *ms)
 24 | {
 25 | #if 0
 26 | 	printf("  Page size: %u\n", ms->ms_psize);
 27 | #endif
 28 | 	printf("  Tree depth: %u\n", ms->ms_depth);
 29 | 	printf("  Branch pages: %"Yu"\n",   ms->ms_branch_pages);
 30 | 	printf("  Leaf pages: %"Yu"\n",     ms->ms_leaf_pages);
 31 | 	printf("  Overflow pages: %"Yu"\n", ms->ms_overflow_pages);
 32 | 	printf("  Entries: %"Yu"\n",        ms->ms_entries);
 33 | }
 34 |
 35 | static void usage(char *prog)
 36 | {
 37 | 	fprintf(stderr, "usage: %s [-V] [-n] [-e] [-r[r]] [-f[f[f]]] [-v] [-a|-s subdb] dbpath\n", prog);
 38 | 	exit(EXIT_FAILURE);
 39 | }
 40 |
 41 | int main(int argc, char *argv[])
 42 | {
 43 | 	int i, rc;
 44 | 	MDB_env *env;
 45 | 	MDB_txn *txn;
 46 | 	MDB_dbi dbi;
 47 | 	MDB_stat mst;
 48 | 	MDB_envinfo mei;
 49 | 	char *prog = argv[0];
 50 | 	char *envname;
 51 | 	char *subname = NULL;
 52 | 	int alldbs = 0, envinfo = 0, envflags = 0, freinfo = 0, rdrinfo = 0;
 53 |
 54 | 	if (argc < 2) {
 55 | 		usage(prog);
 56 | 	}
 57 |
 58 | 	/* -a: print stat of main DB and all subDBs
 59 | 	 * -s: print stat of only the named subDB
 60 | 	 * -e: print env info
 61 | 	 * -f: print freelist info
 62 | 	 * -r: print reader info
 63 | 	 * -n: use NOSUBDIR flag on env_open
 64 | 	 * -v: use previous snapshot
 65 | 	 * -V: print version and exit
 66 | 	 * (default) print stat of only the main DB
 67 | 	 */
 68 | 	while ((i = getopt(argc, argv, "Vaefnrs:v")) != EOF) {
 69 | 		switch(i) {
 70 | 		case 'V':
 71 | 			printf("%s\n", MDB_VERSION_STRING);
 72 | 			exit(0);
 73 | 			break;
 74 | 		case 'a':
 75 | 			if (subname)
 76 | 				usage(prog);
 77 | 			alldbs++;
 78 | 			break;
 79 | 		case 'e':
 80 | 			envinfo++;
 81 | 			break;
 82 | 		case 'f':
 83 | 			freinfo++;
 84 | 			break;
 85 | 		case 'n':
 86 | 			envflags |= MDB_NOSUBDIR;
 87 | 			break;
 88 | 		case 'v':
 89 | 			envflags |= MDB_PREVSNAPSHOT;
 90 | 			break;
 91 | 		case 'r':
 92 | 			rdrinfo++;
 93 | 			break;
 94 | 		case 's':
 95 | 			if (alldbs)
 96 | 				usage(prog);
 97 | 			subname = optarg;
 98 | 			break;
 99 | 		default:
100 | 			usage(prog);
101 | 		}
102 | 	}
103 |
104 | 	if (optind != argc - 1)
105 | 		usage(prog);
106 |
107 | 	envname = argv[optind];
108 | 	rc = mdb_env_create(&env);
109 | 	if (rc) {
110 | 		fprintf(stderr, "mdb_env_create failed, error %d %s\n", rc, mdb_strerror(rc));
111 | 		return EXIT_FAILURE;
112 | 	}
113 |
114 | 	if (alldbs || subname) {
115 | 		mdb_env_set_maxdbs(env, 4);
116 | 	}
117 |
118 | 	rc = mdb_env_open(env, envname, envflags | MDB_RDONLY, 0664);
119 | 	if (rc) {
120 | 		fprintf(stderr, "mdb_env_open failed, error %d %s\n", rc, mdb_strerror(rc));
121 | 		goto env_close;
122 | 	}
123 |
124 | 	if (envinfo) {
125 | 		(void)mdb_env_stat(env, &mst);
126 | 		(void)mdb_env_info(env, &mei);
127 | 		printf("Environment Info\n");
128 | 		printf("  Map address: %p\n", mei.me_mapaddr);
129 | 		printf("  Map size: %"Yu"\n", mei.me_mapsize);
130 | 		printf("  Page size: %u\n", mst.ms_psize);
131 | 		printf("  Max pages: %"Yu"\n", mei.me_mapsize / mst.ms_psize);
132 | 		printf("  Number of pages used: %"Yu"\n", mei.me_last_pgno+1);
133 | 		printf("  Last transaction ID: %"Yu"\n", mei.me_last_txnid);
134 | 		printf("  Max readers: %u\n", mei.me_maxreaders);
135 | 		printf("  Number of readers used: %u\n", mei.me_numreaders);
136 | 	}
137 |
138 | 	if (rdrinfo) {
139 | 		printf("Reader Table Status\n");
140 | 		rc = mdb_reader_list(env, (MDB_msg_func *)fputs, stdout);
141 | 		if (rdrinfo > 1) {
142 | 			int dead;
143 | 			mdb_reader_check(env, &dead);
144 | 			printf("  %d stale readers cleared.\n", dead);
145 | 			rc = mdb_reader_list(env, (MDB_msg_func *)fputs, stdout);
146 | 		}
147 | 		if (!(subname || alldbs || freinfo))
148 | 			goto env_close;
149 | 	}
150 |
151 | 	rc = mdb_txn_begin(env, NULL, MDB_RDONLY, &txn);
152 | 	if (rc) {
153 | 		fprintf(stderr, "mdb_txn_begin failed, error %d %s\n", rc, mdb_strerror(rc));
154 | 		goto env_close;
155 | 	}
156 |
157 | 	if (freinfo) {
158 | 		MDB_cursor *cursor;
159 | 		MDB_val key, data;
160 | 		mdb_size_t pages = 0, *iptr;
161 |
162 | 		printf("Freelist Status\n");
163 | 		dbi = 0;
164 | 		rc = mdb_cursor_open(txn, dbi, &cursor);
165 | 		if (rc) {
166 | 			fprintf(stderr, "mdb_cursor_open failed, error %d %s\n", rc, mdb_strerror(rc));
167 | 			goto txn_abort;
168 | 		}
169 | 		rc = mdb_stat(txn, dbi, &mst);
170 | 		if (rc) {
171 | 			fprintf(stderr, "mdb_stat failed, error %d %s\n", rc, mdb_strerror(rc));
172 | 			goto txn_abort;
173 | 		}
174 | 		prstat(&mst);
175 | 		while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
176 | 			iptr = data.mv_data;
177 | 			pages += *iptr;
178 | 			if (freinfo > 1) {
179 | 				char *bad = "";
180 | 				mdb_size_t pg, prev;
181 | 				ssize_t i, j, span = 0;
182 | 				j = *iptr++;
183 | 				for (i = j, prev = 1; --i >= 0; ) {
184 | 					pg = iptr[i];
185 | 					if (pg <= prev)
186 | 						bad = " [bad sequence]";
187 | 					prev = pg;
188 | 					pg += span;
189 | 					for (; i >= span && iptr[i-span] == pg; span++, pg++) ;
190 | 				}
191 | 				printf("    Transaction %"Yu", %"Z"d pages, maxspan %"Z"d%s\n",
192 | 					*(mdb_size_t *)key.mv_data, j, span, bad);
193 | 				if (freinfo > 2) {
194 | 					for (--j; j >= 0; ) {
195 | 						pg = iptr[j];
196 | 						for (span=1; --j >= 0 && iptr[j] == pg+span; span++) ;
197 | 						printf(span>1 ? "     %9"Yu"[%"Z"d]\n" : "     %9"Yu"\n",
198 | 							pg, span);
199 | 					}
200 | 				}
201 | 			}
202 | 		}
203 | 		mdb_cursor_close(cursor);
204 | 		printf("  Free pages: %"Yu"\n", pages);
205 | 	}
206 |
207 | 	rc = mdb_open(txn, subname, 0, &dbi);
208 | 	if (rc) {
209 | 		fprintf(stderr, "mdb_open failed, error %d %s\n", rc, mdb_strerror(rc));
210 | 		goto txn_abort;
211 | 	}
212 |
213 | 	rc = mdb_stat(txn, dbi, &mst);
214 | 	if (rc) {
215 | 		fprintf(stderr, "mdb_stat failed, error %d %s\n", rc, mdb_strerror(rc));
216 | 		goto txn_abort;
217 | 	}
218 | 	printf("Status of %s\n", subname ? subname : "Main DB");
219 | 	prstat(&mst);
220 |
221 | 	if (alldbs) {
222 | 		MDB_cursor *cursor;
223 | 		MDB_val key;
224 |
225 | 		rc = mdb_cursor_open(txn, dbi, &cursor);
226 | 		if (rc) {
227 | 			fprintf(stderr, "mdb_cursor_open failed, error %d %s\n", rc, mdb_strerror(rc));
228 | 			goto txn_abort;
229 | 		}
230 | 		while ((rc = mdb_cursor_get(cursor, &key, NULL, MDB_NEXT_NODUP)) == 0) {
231 | 			char *str;
232 | 			MDB_dbi db2;
233 | 			if (memchr(key.mv_data, '\0', key.mv_size))
234 | 				continue;
235 | 			str = malloc(key.mv_size+1);
236 | 			memcpy(str, key.mv_data, key.mv_size);
237 | 			str[key.mv_size] = '\0';
238 | 			rc = mdb_open(txn, str, 0, &db2);
239 | 			if (rc == MDB_SUCCESS)
240 | 				printf("Status of %s\n", str);
241 | 			free(str);
242 | 			if (rc) continue;
243 | 			rc = mdb_stat(txn, db2, &mst);
244 | 			if (rc) {
245 | 				fprintf(stderr, "mdb_stat failed, error %d %s\n", rc, mdb_strerror(rc));
246 | 				goto txn_abort;
247 | 			}
248 | 			prstat(&mst);
249 | 			mdb_close(env, db2);
250 | 		}
251 | 		mdb_cursor_close(cursor);
252 | 	}
253 |
254 | 	if (rc == MDB_NOTFOUND)
255 | 		rc = MDB_SUCCESS;
256 |
257 | 	mdb_close(env, dbi);
258 | txn_abort:
259 | 	mdb_txn_abort(txn);
260 | env_close:
261 | 	mdb_env_close(env);
262 |
263 | 	return rc ? EXIT_FAILURE : EXIT_SUCCESS;
264 | }
265 |


--------------------------------------------------------------------------------
/libraries/liblmdb/midl.c:
--------------------------------------------------------------------------------
  1 | /**	@file midl.c
  2 |  *	@brief ldap bdb back-end ID List functions */
  3 | /* $OpenLDAP$ */
  4 | /* This work is part of OpenLDAP Software <http://www.openldap.org/>.
  5 |  *
  6 |  * Copyright 2000-2021 The OpenLDAP Foundation.
  7 |  * Portions Copyright 2001-2021 Howard Chu, Symas Corp.
  8 |  * All rights reserved.
  9 |  *
 10 |  * Redistribution and use in source and binary forms, with or without
 11 |  * modification, are permitted only as authorized by the OpenLDAP
 12 |  * Public License.
 13 |  *
 14 |  * A copy of this license is available in the file LICENSE in the
 15 |  * top-level directory of the distribution or, alternatively, at
 16 |  * <http://www.OpenLDAP.org/license.html>.
 17 |  */
 18 |
 19 | #include <limits.h>
 20 | #include <string.h>
 21 | #include <stdlib.h>
 22 | #include <errno.h>
 23 | #include <sys/types.h>
 24 | #include "midl.h"
 25 |
 26 | /** @defgroup internal	LMDB Internals
 27 |  *	@{
 28 |  */
 29 | /** @defgroup idls	ID List Management
 30 |  *	@{
 31 |  */
 32 | #define CMP(x,y)	 ( (x) < (y) ? -1 : (x) > (y) )
 33 |
 34 | unsigned mdb_midl_search( MDB_IDL ids, MDB_ID id )
 35 | {
 36 | 	/*
 37 | 	 * binary search of id in ids
 38 | 	 * if found, returns position of id
 39 | 	 * if not found, returns first position greater than id
 40 | 	 */
 41 | 	unsigned base = 0;
 42 | 	unsigned cursor = 1;
 43 | 	int val = 0;
 44 | 	unsigned n = ids[0];
 45 |
 46 | 	while( 0 < n ) {
 47 | 		unsigned pivot = n >> 1;
 48 | 		cursor = base + pivot + 1;
 49 | 		val = CMP( ids[cursor], id );
 50 |
 51 | 		if( val < 0 ) {
 52 | 			n = pivot;
 53 |
 54 | 		} else if ( val > 0 ) {
 55 | 			base = cursor;
 56 | 			n -= pivot + 1;
 57 |
 58 | 		} else {
 59 | 			return cursor;
 60 | 		}
 61 | 	}
 62 |
 63 | 	if( val > 0 ) {
 64 | 		++cursor;
 65 | 	}
 66 | 	return cursor;
 67 | }
 68 |
 69 | #if 0	/* superseded by append/sort */
 70 | int mdb_midl_insert( MDB_IDL ids, MDB_ID id )
 71 | {
 72 | 	unsigned x, i;
 73 |
 74 | 	x = mdb_midl_search( ids, id );
 75 | 	assert( x > 0 );
 76 |
 77 | 	if( x < 1 ) {
 78 | 		/* internal error */
 79 | 		return -2;
 80 | 	}
 81 |
 82 | 	if ( x <= ids[0] && ids[x] == id ) {
 83 | 		/* duplicate */
 84 | 		assert(0);
 85 | 		return -1;
 86 | 	}
 87 |
 88 | 	if ( ++ids[0] >= MDB_IDL_DB_MAX ) {
 89 | 		/* no room */
 90 | 		--ids[0];
 91 | 		return -2;
 92 |
 93 | 	} else {
 94 | 		/* insert id */
 95 | 		for (i=ids[0]; i>x; i--)
 96 | 			ids[i] = ids[i-1];
 97 | 		ids[x] = id;
 98 | 	}
 99 |
100 | 	return 0;
101 | }
102 | #endif
103 |
104 | MDB_IDL mdb_midl_alloc(int num)
105 | {
106 | 	MDB_IDL ids = malloc((num+2) * sizeof(MDB_ID));
107 | 	if (ids) {
108 | 		*ids++ = num;
109 | 		*ids = 0;
110 | 	}
111 | 	return ids;
112 | }
113 |
114 | void mdb_midl_free(MDB_IDL ids)
115 | {
116 | 	if (ids)
117 | 		free(ids-1);
118 | }
119 |
120 | void mdb_midl_shrink( MDB_IDL *idp )
121 | {
122 | 	MDB_IDL ids = *idp;
123 | 	if (*(--ids) > MDB_IDL_UM_MAX &&
124 | 		(ids = realloc(ids, (MDB_IDL_UM_MAX+2) * sizeof(MDB_ID))))
125 | 	{
126 | 		*ids++ = MDB_IDL_UM_MAX;
127 | 		*idp = ids;
128 | 	}
129 | }
130 |
131 | static int mdb_midl_grow( MDB_IDL *idp, int num )
132 | {
133 | 	MDB_IDL idn = *idp-1;
134 | 	/* grow it */
135 | 	idn = realloc(idn, (*idn + num + 2) * sizeof(MDB_ID));
136 | 	if (!idn)
137 | 		return ENOMEM;
138 | 	*idn++ += num;
139 | 	*idp = idn;
140 | 	return 0;
141 | }
142 |
143 | int mdb_midl_need( MDB_IDL *idp, unsigned num )
144 | {
145 | 	MDB_IDL ids = *idp;
146 | 	num += ids[0];
147 | 	if (num > ids[-1]) {
148 | 		num = (num + num/4 + (256 + 2)) & -256;
149 | 		if (!(ids = realloc(ids-1, num * sizeof(MDB_ID))))
150 | 			return ENOMEM;
151 | 		*ids++ = num - 2;
152 | 		*idp = ids;
153 | 	}
154 | 	return 0;
155 | }
156 |
157 | int mdb_midl_append( MDB_IDL *idp, MDB_ID id )
158 | {
159 | 	MDB_IDL ids = *idp;
160 | 	/* Too big? */
161 | 	if (ids[0] >= ids[-1]) {
162 | 		if (mdb_midl_grow(idp, MDB_IDL_UM_MAX))
163 | 			return ENOMEM;
164 | 		ids = *idp;
165 | 	}
166 | 	ids[0]++;
167 | 	ids[ids[0]] = id;
168 | 	return 0;
169 | }
170 |
171 | int mdb_midl_append_list( MDB_IDL *idp, MDB_IDL app )
172 | {
173 | 	MDB_IDL ids = *idp;
174 | 	/* Too big? */
175 | 	if (ids[0] + app[0] >= ids[-1]) {
176 | 		if (mdb_midl_grow(idp, app[0]))
177 | 			return ENOMEM;
178 | 		ids = *idp;
179 | 	}
180 | 	memcpy(&ids[ids[0]+1], &app[1], app[0] * sizeof(MDB_ID));
181 | 	ids[0] += app[0];
182 | 	return 0;
183 | }
184 |
185 | int mdb_midl_append_range( MDB_IDL *idp, MDB_ID id, unsigned n )
186 | {
187 | 	MDB_ID *ids = *idp, len = ids[0];
188 | 	/* Too big? */
189 | 	if (len + n > ids[-1]) {
190 | 		if (mdb_midl_grow(idp, n | MDB_IDL_UM_MAX))
191 | 			return ENOMEM;
192 | 		ids = *idp;
193 | 	}
194 | 	ids[0] = len + n;
195 | 	ids += len;
196 | 	while (n)
197 | 		ids[n--] = id++;
198 | 	return 0;
199 | }
200 |
201 | void mdb_midl_xmerge( MDB_IDL idl, MDB_IDL merge )
202 | {
203 | 	MDB_ID old_id, merge_id, i = merge[0], j = idl[0], k = i+j, total = k;
204 | 	idl[0] = (MDB_ID)-1;		/* delimiter for idl scan below */
205 | 	old_id = idl[j];
206 | 	while (i) {
207 | 		merge_id = merge[i--];
208 | 		for (; old_id < merge_id; old_id = idl[--j])
209 | 			idl[k--] = old_id;
210 | 		idl[k--] = merge_id;
211 | 	}
212 | 	idl[0] = total;
213 | }
214 |
215 | /* Quicksort + Insertion sort for small arrays */
216 |
217 | #define SMALL	8
218 | #define	MIDL_SWAP(a,b)	{ itmp=(a); (a)=(b); (b)=itmp; }
219 |
220 | void
221 | mdb_midl_sort( MDB_IDL ids )
222 | {
223 | 	/* Max possible depth of int-indexed tree * 2 items/level */
224 | 	int istack[sizeof(int)*CHAR_BIT * 2];
225 | 	int i,j,k,l,ir,jstack;
226 | 	MDB_ID a, itmp;
227 |
228 | 	ir = (int)ids[0];
229 | 	l = 1;
230 | 	jstack = 0;
231 | 	for(;;) {
232 | 		if (ir - l < SMALL) {	/* Insertion sort */
233 | 			for (j=l+1;j<=ir;j++) {
234 | 				a = ids[j];
235 | 				for (i=j-1;i>=1;i--) {
236 | 					if (ids[i] >= a) break;
237 | 					ids[i+1] = ids[i];
238 | 				}
239 | 				ids[i+1] = a;
240 | 			}
241 | 			if (jstack == 0) break;
242 | 			ir = istack[jstack--];
243 | 			l = istack[jstack--];
244 | 		} else {
245 | 			k = (l + ir) >> 1;	/* Choose median of left, center, right */
246 | 			MIDL_SWAP(ids[k], ids[l+1]);
247 | 			if (ids[l] < ids[ir]) {
248 | 				MIDL_SWAP(ids[l], ids[ir]);
249 | 			}
250 | 			if (ids[l+1] < ids[ir]) {
251 | 				MIDL_SWAP(ids[l+1], ids[ir]);
252 | 			}
253 | 			if (ids[l] < ids[l+1]) {
254 | 				MIDL_SWAP(ids[l], ids[l+1]);
255 | 			}
256 | 			i = l+1;
257 | 			j = ir;
258 | 			a = ids[l+1];
259 | 			for(;;) {
260 | 				do i++; while(ids[i] > a);
261 | 				do j--; while(ids[j] < a);
262 | 				if (j < i) break;
263 | 				MIDL_SWAP(ids[i],ids[j]);
264 | 			}
265 | 			ids[l+1] = ids[j];
266 | 			ids[j] = a;
267 | 			jstack += 2;
268 | 			if (ir-i+1 >= j-l) {
269 | 				istack[jstack] = ir;
270 | 				istack[jstack-1] = i;
271 | 				ir = j-1;
272 | 			} else {
273 | 				istack[jstack] = j-1;
274 | 				istack[jstack-1] = l;
275 | 				l = i;
276 | 			}
277 | 		}
278 | 	}
279 | }
280 |
281 | unsigned mdb_mid2l_search( MDB_ID2L ids, MDB_ID id )
282 | {
283 | 	/*
284 | 	 * binary search of id in ids
285 | 	 * if found, returns position of id
286 | 	 * if not found, returns first position greater than id
287 | 	 */
288 | 	unsigned base = 0;
289 | 	unsigned cursor = 1;
290 | 	int val = 0;
291 | 	unsigned n = (unsigned)ids[0].mid;
292 |
293 | 	while( 0 < n ) {
294 | 		unsigned pivot = n >> 1;
295 | 		cursor = base + pivot + 1;
296 | 		val = CMP( id, ids[cursor].mid );
297 |
298 | 		if( val < 0 ) {
299 | 			n = pivot;
300 |
301 | 		} else if ( val > 0 ) {
302 | 			base = cursor;
303 | 			n -= pivot + 1;
304 |
305 | 		} else {
306 | 			return cursor;
307 | 		}
308 | 	}
309 |
310 | 	if( val > 0 ) {
311 | 		++cursor;
312 | 	}
313 | 	return cursor;
314 | }
315 |
316 | int mdb_mid2l_insert( MDB_ID2L ids, MDB_ID2 *id )
317 | {
318 | 	unsigned x, i;
319 |
320 | 	x = mdb_mid2l_search( ids, id->mid );
321 |
322 | 	if( x < 1 ) {
323 | 		/* internal error */
324 | 		return -2;
325 | 	}
326 |
327 | 	if ( x <= ids[0].mid && ids[x].mid == id->mid ) {
328 | 		/* duplicate */
329 | 		return -1;
330 | 	}
331 |
332 | 	if ( ids[0].mid >= MDB_IDL_UM_MAX ) {
333 | 		/* too big */
334 | 		return -2;
335 |
336 | 	} else {
337 | 		/* insert id */
338 | 		ids[0].mid++;
339 | 		for (i=(unsigned)ids[0].mid; i>x; i--)
340 | 			ids[i] = ids[i-1];
341 | 		ids[x] = *id;
342 | 	}
343 |
344 | 	return 0;
345 | }
346 |
347 | int mdb_mid2l_append( MDB_ID2L ids, MDB_ID2 *id )
348 | {
349 | 	/* Too big? */
350 | 	if (ids[0].mid >= MDB_IDL_UM_MAX) {
351 | 		return -2;
352 | 	}
353 | 	ids[0].mid++;
354 | 	ids[ids[0].mid] = *id;
355 | 	return 0;
356 | }
357 |
358 | #ifdef MDB_VL32
359 | unsigned mdb_mid3l_search( MDB_ID3L ids, MDB_ID id )
360 | {
361 | 	/*
362 | 	 * binary search of id in ids
363 | 	 * if found, returns position of id
364 | 	 * if not found, returns first position greater than id
365 | 	 */
366 | 	unsigned base = 0;
367 | 	unsigned cursor = 1;
368 | 	int val = 0;
369 | 	unsigned n = (unsigned)ids[0].mid;
370 |
371 | 	while( 0 < n ) {
372 | 		unsigned pivot = n >> 1;
373 | 		cursor = base + pivot + 1;
374 | 		val = CMP( id, ids[cursor].mid );
375 |
376 | 		if( val < 0 ) {
377 | 			n = pivot;
378 |
379 | 		} else if ( val > 0 ) {
380 | 			base = cursor;
381 | 			n -= pivot + 1;
382 |
383 | 		} else {
384 | 			return cursor;
385 | 		}
386 | 	}
387 |
388 | 	if( val > 0 ) {
389 | 		++cursor;
390 | 	}
391 | 	return cursor;
392 | }
393 |
394 | int mdb_mid3l_insert( MDB_ID3L ids, MDB_ID3 *id )
395 | {
396 | 	unsigned x, i;
397 |
398 | 	x = mdb_mid3l_search( ids, id->mid );
399 |
400 | 	if( x < 1 ) {
401 | 		/* internal error */
402 | 		return -2;
403 | 	}
404 |
405 | 	if ( x <= ids[0].mid && ids[x].mid == id->mid ) {
406 | 		/* duplicate */
407 | 		return -1;
408 | 	}
409 |
410 | 	/* insert id */
411 | 	ids[0].mid++;
412 | 	for (i=(unsigned)ids[0].mid; i>x; i--)
413 | 		ids[i] = ids[i-1];
414 | 	ids[x] = *id;
415 |
416 | 	return 0;
417 | }
418 | #endif /* MDB_VL32 */
419 |
420 | /** @} */
421 | /** @} */
422 |


--------------------------------------------------------------------------------
/libraries/liblmdb/midl.h:
--------------------------------------------------------------------------------
  1 | /**	@file midl.h
  2 |  *	@brief LMDB ID List header file.
  3 |  *
  4 |  *	This file was originally part of back-bdb but has been
  5 |  *	modified for use in libmdb. Most of the macros defined
  6 |  *	in this file are unused, just left over from the original.
  7 |  *
  8 |  *	This file is only used internally in libmdb and its definitions
  9 |  *	are not exposed publicly.
 10 |  */
 11 | /* $OpenLDAP$ */
 12 | /* This work is part of OpenLDAP Software <http://www.openldap.org/>.
 13 |  *
 14 |  * Copyright 2000-2021 The OpenLDAP Foundation.
 15 |  * Portions Copyright 2001-2021 Howard Chu, Symas Corp.
 16 |  * All rights reserved.
 17 |  *
 18 |  * Redistribution and use in source and binary forms, with or without
 19 |  * modification, are permitted only as authorized by the OpenLDAP
 20 |  * Public License.
 21 |  *
 22 |  * A copy of this license is available in the file LICENSE in the
 23 |  * top-level directory of the distribution or, alternatively, at
 24 |  * <http://www.OpenLDAP.org/license.html>.
 25 |  */
 26 |
 27 | #ifndef _MDB_MIDL_H_
 28 | #define _MDB_MIDL_H_
 29 |
 30 | #include "lmdb.h"
 31 |
 32 | #ifdef __cplusplus
 33 | extern "C" {
 34 | #endif
 35 |
 36 | /** @defgroup internal	LMDB Internals
 37 |  *	@{
 38 |  */
 39 |
 40 | /** @defgroup idls	ID List Management
 41 |  *	@{
 42 |  */
 43 | 	/** A generic unsigned ID number. These were entryIDs in back-bdb.
 44 | 	 *	Preferably it should have the same size as a pointer.
 45 | 	 */
 46 | typedef mdb_size_t MDB_ID;
 47 |
 48 | 	/** An IDL is an ID List, a sorted array of IDs. The first
 49 | 	 * element of the array is a counter for how many actual
 50 | 	 * IDs are in the list. In the original back-bdb code, IDLs are
 51 | 	 * sorted in ascending order. For libmdb IDLs are sorted in
 52 | 	 * descending order.
 53 | 	 */
 54 | typedef MDB_ID *MDB_IDL;
 55 |
 56 | /* IDL sizes - likely should be even bigger
 57 |  *   limiting factors: sizeof(ID), thread stack size
 58 |  */
 59 | #ifndef MDB_IDL_LOGN
 60 | #define	MDB_IDL_LOGN	16	/* DB_SIZE is 2^16, UM_SIZE is 2^17 */
 61 | #endif
 62 | #define MDB_IDL_DB_SIZE		(1<<MDB_IDL_LOGN)
 63 | #define MDB_IDL_UM_SIZE		(1<<(MDB_IDL_LOGN+1))
 64 |
 65 | #define MDB_IDL_DB_MAX		(MDB_IDL_DB_SIZE-1)
 66 | #define MDB_IDL_UM_MAX		(MDB_IDL_UM_SIZE-1)
 67 |
 68 | #define MDB_IDL_SIZEOF(ids)		(((ids)[0]+1) * sizeof(MDB_ID))
 69 | #define MDB_IDL_IS_ZERO(ids) ( (ids)[0] == 0 )
 70 | #define MDB_IDL_CPY( dst, src ) (memcpy( dst, src, MDB_IDL_SIZEOF( src ) ))
 71 | #define MDB_IDL_FIRST( ids )	( (ids)[1] )
 72 | #define MDB_IDL_LAST( ids )		( (ids)[(ids)[0]] )
 73 |
 74 | 	/** Current max length of an #mdb_midl_alloc()ed IDL */
 75 | #define MDB_IDL_ALLOCLEN( ids )	( (ids)[-1] )
 76 |
 77 | 	/** Append ID to IDL. The IDL must be big enough. */
 78 | #define mdb_midl_xappend(idl, id) do { \
 79 | 		MDB_ID *xidl = (idl), xlen = ++(xidl[0]); \
 80 | 		xidl[xlen] = (id); \
 81 | 	} while (0)
 82 |
 83 | 	/** Search for an ID in an IDL.
 84 | 	 * @param[in] ids	The IDL to search.
 85 | 	 * @param[in] id	The ID to search for.
 86 | 	 * @return	The index of the first ID greater than or equal to \b id.
 87 | 	 */
 88 | unsigned mdb_midl_search( MDB_IDL ids, MDB_ID id );
 89 |
 90 | 	/** Allocate an IDL.
 91 | 	 * Allocates memory for an IDL of the given size.
 92 | 	 * @return	IDL on success, NULL on failure.
 93 | 	 */
 94 | MDB_IDL mdb_midl_alloc(int num);
 95 |
 96 | 	/** Free an IDL.
 97 | 	 * @param[in] ids	The IDL to free.
 98 | 	 */
 99 | void mdb_midl_free(MDB_IDL ids);
100 |
101 | 	/** Shrink an IDL.
102 | 	 * Return the IDL to the default size if it has grown larger.
103 | 	 * @param[in,out] idp	Address of the IDL to shrink.
104 | 	 */
105 | void mdb_midl_shrink(MDB_IDL *idp);
106 |
107 | 	/** Make room for num additional elements in an IDL.
108 | 	 * @param[in,out] idp	Address of the IDL.
109 | 	 * @param[in] num	Number of elements to make room for.
110 | 	 * @return	0 on success, ENOMEM on failure.
111 | 	 */
112 | int mdb_midl_need(MDB_IDL *idp, unsigned num);
113 |
114 | 	/** Append an ID onto an IDL.
115 | 	 * @param[in,out] idp	Address of the IDL to append to.
116 | 	 * @param[in] id	The ID to append.
117 | 	 * @return	0 on success, ENOMEM if the IDL is too large.
118 | 	 */
119 | int mdb_midl_append( MDB_IDL *idp, MDB_ID id );
120 |
121 | 	/** Append an IDL onto an IDL.
122 | 	 * @param[in,out] idp	Address of the IDL to append to.
123 | 	 * @param[in] app	The IDL to append.
124 | 	 * @return	0 on success, ENOMEM if the IDL is too large.
125 | 	 */
126 | int mdb_midl_append_list( MDB_IDL *idp, MDB_IDL app );
127 |
128 | 	/** Append an ID range onto an IDL.
129 | 	 * @param[in,out] idp	Address of the IDL to append to.
130 | 	 * @param[in] id	The lowest ID to append.
131 | 	 * @param[in] n		Number of IDs to append.
132 | 	 * @return	0 on success, ENOMEM if the IDL is too large.
133 | 	 */
134 | int mdb_midl_append_range( MDB_IDL *idp, MDB_ID id, unsigned n );
135 |
136 | 	/** Merge an IDL onto an IDL. The destination IDL must be big enough.
137 | 	 * @param[in] idl	The IDL to merge into.
138 | 	 * @param[in] merge	The IDL to merge.
139 | 	 */
140 | void mdb_midl_xmerge( MDB_IDL idl, MDB_IDL merge );
141 |
142 | 	/** Sort an IDL.
143 | 	 * @param[in,out] ids	The IDL to sort.
144 | 	 */
145 | void mdb_midl_sort( MDB_IDL ids );
146 |
147 | 	/** An ID2 is an ID/pointer pair.
148 | 	 */
149 | typedef struct MDB_ID2 {
150 | 	MDB_ID mid;		/**< The ID */
151 | 	void *mptr;		/**< The pointer */
152 | } MDB_ID2;
153 |
154 | 	/** An ID2L is an ID2 List, a sorted array of ID2s.
155 | 	 * The first element's \b mid member is a count of how many actual
156 | 	 * elements are in the array. The \b mptr member of the first element is unused.
157 | 	 * The array is sorted in ascending order by \b mid.
158 | 	 */
159 | typedef MDB_ID2 *MDB_ID2L;
160 |
161 | 	/** Search for an ID in an ID2L.
162 | 	 * @param[in] ids	The ID2L to search.
163 | 	 * @param[in] id	The ID to search for.
164 | 	 * @return	The index of the first ID2 whose \b mid member is greater than or equal to \b id.
165 | 	 */
166 | unsigned mdb_mid2l_search( MDB_ID2L ids, MDB_ID id );
167 |
168 |
169 | 	/** Insert an ID2 into a ID2L.
170 | 	 * @param[in,out] ids	The ID2L to insert into.
171 | 	 * @param[in] id	The ID2 to insert.
172 | 	 * @return	0 on success, -1 if the ID was already present in the ID2L.
173 | 	 */
174 | int mdb_mid2l_insert( MDB_ID2L ids, MDB_ID2 *id );
175 |
176 | 	/** Append an ID2 into a ID2L.
177 | 	 * @param[in,out] ids	The ID2L to append into.
178 | 	 * @param[in] id	The ID2 to append.
179 | 	 * @return	0 on success, -2 if the ID2L is too big.
180 | 	 */
181 | int mdb_mid2l_append( MDB_ID2L ids, MDB_ID2 *id );
182 |
183 | #ifdef MDB_VL32
184 | typedef struct MDB_ID3 {
185 | 	MDB_ID mid;		/**< The ID */
186 | 	void *mptr;		/**< The pointer */
187 | 	unsigned int mcnt;		/**< Number of pages */
188 | 	unsigned int mref;		/**< Refcounter */
189 | } MDB_ID3;
190 |
191 | typedef MDB_ID3 *MDB_ID3L;
192 |
193 | unsigned mdb_mid3l_search( MDB_ID3L ids, MDB_ID id );
194 | int mdb_mid3l_insert( MDB_ID3L ids, MDB_ID3 *id );
195 |
196 | #endif /* MDB_VL32 */
197 | /** @} */
198 | /** @} */
199 | #ifdef __cplusplus
200 | }
201 | #endif
202 | #endif	/* _MDB_MIDL_H_ */
203 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mplay.c:
--------------------------------------------------------------------------------
  1 | /* mplay.c - memory-mapped database log replay */
  2 | /*
  3 |  * Copyright 2011-2023 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 | #include <stdio.h>
 15 | #include <stdlib.h>
 16 | #include <unistd.h>
 17 | #include <time.h>
 18 | #include <string.h>
 19 | #include <ctype.h>
 20 | #include <assert.h>
 21 | #include <sys/types.h>
 22 | #include <sys/wait.h>
 23 |
 24 | #include "lmdb.h"
 25 |
 26 | #define E(expr) CHECK((rc = (expr)) == MDB_SUCCESS, #expr)
 27 | #define RES(err, expr) ((rc = expr) == (err) || (CHECK(!rc, #expr), 0))
 28 | #define CHECK(test, msg) ((test) ? (void)0 : ((void)fprintf(stderr, \
 29 | 	"%s:%d: %s: %s\n", __FILE__, __LINE__, msg, mdb_strerror(rc)), abort()))
 30 |
 31 | #define SCMP(s)	s, (sizeof(s)-1)
 32 | char inbuf[8192];
 33 | char *dbuf, *kbuf;
 34 | size_t dbufsize;
 35 | int maxkey;
 36 |
 37 | #define SOFF(s)	(sizeof(s)+1)
 38 |
 39 | #define MAXENVS	16
 40 | #define MAXTXNS	16
 41 | #define MAXCRSS	16
 42 |
 43 | #define MAXPIDS	16
 44 |
 45 | typedef struct crspair {
 46 | 	void *tcrs;	/* scanned text pointer */
 47 | 	MDB_cursor *rcrs;
 48 | } crspair;
 49 |
 50 | typedef struct txnpair {
 51 | 	void *ttxn;	/* scanned text pointer */
 52 | 	MDB_txn *rtxn;
 53 | 	crspair cursors[MAXCRSS];
 54 | 	int ncursors;
 55 | } txnpair;
 56 |
 57 | typedef struct envpair {
 58 | 	void *tenv;
 59 | 	MDB_env *renv;
 60 | 	txnpair txns[MAXTXNS];
 61 | 	int ntxns;
 62 | } envpair;
 63 |
 64 | envpair envs[MAXENVS];
 65 | int nenvs;
 66 |
 67 | envpair *lastenv;
 68 | txnpair *lasttxn;
 69 | crspair *lastcrs;
 70 |
 71 | typedef struct pidpair {
 72 | 	int tpid;
 73 | 	pid_t rpid;
 74 | 	int fdout, fdin;
 75 | } pidpair;
 76 |
 77 | pidpair *lastpid;
 78 |
 79 | pidpair pids[MAXPIDS];
 80 | int npids;
 81 |
 82 | unsigned long lcount;
 83 |
 84 | static int unhex(unsigned char *c2)
 85 | {
 86 | 	int x, c;
 87 | 	x = *c2++ & 0x4f;
 88 | 	if (x & 0x40)
 89 | 		x -= 55;
 90 | 	c = x << 4;
 91 | 	x = *c2 & 0x4f;
 92 | 	if (x & 0x40)
 93 | 		x -= 55;
 94 | 	c |= x;
 95 | 	return c;
 96 | }
 97 |
 98 | int inhex(char *in, char *out)
 99 | {
100 | 	char *c2 = out;
101 | 	while (isxdigit(*in)) {
102 | 		*c2++ = unhex((unsigned char *)in);
103 | 		in += 2;
104 | 	}
105 | 	return c2 - out;
106 | }
107 |
108 | static void addenv(void *tenv, MDB_env *renv)
109 | {
110 | 	assert(nenvs < MAXENVS);
111 | 	envs[nenvs].tenv = tenv;
112 | 	envs[nenvs].renv = renv;
113 | 	envs[nenvs].ntxns = 0;
114 | 	lastenv = envs+nenvs;
115 | 	nenvs++;
116 | }
117 |
118 | static envpair *findenv(void *tenv)
119 | {
120 | 	int i;
121 | 	if (!lastenv || lastenv->tenv != tenv) {
122 | 		for (i=0; i<nenvs; i++)
123 | 			if (envs[i].tenv == tenv)
124 | 				break;
125 | 		assert(i < nenvs);
126 | 		lastenv = &envs[i];
127 | 	}
128 | 	return lastenv;
129 | }
130 |
131 | static void delenv(envpair *ep)
132 | {
133 | 	int i = ep - envs;
134 | 	for (; i<nenvs-1; i++)
135 | 		envs[i] = envs[i+1];
136 | 	nenvs--;
137 | 	lastenv = NULL;
138 | }
139 |
140 | static void addtxn(void *tenv, void *ttxn, MDB_txn *rtxn)
141 | {
142 | 	envpair *ep;
143 | 	txnpair *tp;
144 |
145 | 	ep = findenv(tenv);
146 | 	assert(ep->ntxns < MAXTXNS);
147 | 	tp = ep->txns+ep->ntxns;
148 | 	tp->ttxn = ttxn;
149 | 	tp->rtxn = rtxn;
150 | 	tp->ncursors = 0;
151 | 	ep->ntxns++;
152 | 	lasttxn = tp;
153 | }
154 |
155 | static txnpair *findtxn(void *ttxn)
156 | {
157 | 	int i, j;
158 | 	if (lasttxn && lasttxn->ttxn == ttxn)
159 | 		return lasttxn;
160 | 	if (lastenv) {
161 | 		for (i=0; i<lastenv->ntxns; i++) {
162 | 			if (lastenv->txns[i].ttxn == ttxn) {
163 | 				lasttxn = lastenv->txns+i;
164 | 				return lasttxn;
165 | 			}
166 | 		}
167 | 	}
168 | 	for (i=0; i<nenvs; i++) {
169 | 		if (envs+i == lastenv) continue;
170 | 		for (j=0; j<envs[i].ntxns; j++) {
171 | 			if (envs[i].txns[j].ttxn == ttxn) {
172 | 				lastenv = envs+i;
173 | 				lasttxn = envs[i].txns+j;
174 | 				return lasttxn;
175 | 			}
176 | 		}
177 | 	}
178 | 	assert(0);	/* should have found it */
179 | }
180 |
181 | static void deltxn(txnpair *tp)
182 | {
183 | 	int i = tp - lastenv->txns;
184 | 	for (; i<lastenv->ntxns-1; i++)
185 | 		lastenv->txns[i] = lastenv->txns[i+1];
186 | 	lastenv->ntxns--;
187 | 	lasttxn = NULL;
188 | }
189 |
190 | static void addcrs(txnpair *tp, void *tcrs, MDB_cursor *rcrs)
191 | {
192 | 	int j = tp->ncursors;
193 | 	assert(tp->ncursors < MAXCRSS);
194 |
195 | 	tp->cursors[j].tcrs = tcrs;
196 | 	tp->cursors[j].rcrs = rcrs;
197 | 	tp->ncursors++;
198 | 	lastcrs = tp->cursors+j;
199 | }
200 |
201 | static crspair *findcrs(void *tcrs)
202 | {
203 | 	int i, j, k;
204 | 	envpair *ep;
205 | 	txnpair *tp;
206 | 	crspair *cp;
207 | 	if (lastcrs && lastcrs->tcrs == tcrs)
208 | 		return lastcrs;
209 | 	if (lasttxn) {
210 | 		for (k=0, cp=lasttxn->cursors; k<lasttxn->ncursors; k++, cp++) {
211 | 			if (cp->tcrs == tcrs) {
212 | 				lastcrs = cp;
213 | 				return lastcrs;
214 | 			}
215 | 		}
216 | 	}
217 | 	if (lastenv) {
218 | 		for (j=0, tp=lastenv->txns; j<lastenv->ntxns; j++, tp++){
219 | 			if (tp == lasttxn)
220 | 				continue;
221 | 			for (k=0, cp = tp->cursors; k<tp->ncursors; k++, cp++) {
222 | 				if (cp->tcrs == tcrs) {
223 | 					lastcrs = cp;
224 | 					lasttxn = tp;
225 | 					return lastcrs;
226 | 				}
227 | 			}
228 | 		}
229 | 	}
230 | 	for (i=0, ep=envs; i<nenvs; i++, ep++) {
231 | 		for (j=0, tp=ep->txns; j<ep->ntxns; j++, tp++) {
232 | 			if (tp == lasttxn)
233 | 				continue;
234 | 			for (k=0, cp = tp->cursors; k<tp->ncursors; k++, cp++) {
235 | 				if (cp->tcrs == tcrs) {
236 | 					lastcrs = cp;
237 | 					lasttxn = tp;
238 | 					lastenv = ep;
239 | 					return lastcrs;
240 | 				}
241 | 			}
242 | 		}
243 | 	}
244 | 	assert(0);	/* should have found it already */
245 | }
246 |
247 | static void delcrs(void *tcrs)
248 | {
249 | 	int i;
250 | 	crspair *cp = findcrs(tcrs);
251 | 	mdb_cursor_close(cp->rcrs);
252 | 	for (i = cp - lasttxn->cursors; i<lasttxn->ncursors-1; i++)
253 | 		lasttxn->cursors[i] = lasttxn->cursors[i+1];
254 | 	lasttxn->ncursors--;
255 | 	lastcrs = NULL;
256 | }
257 |
258 | void child()
259 | {
260 | 	int rc;
261 | 	MDB_val key, data;
262 | 	char *ptr;
263 |
264 | 	while (fgets(inbuf, sizeof(inbuf), stdin)) {
265 | 		ptr = inbuf;
266 | 		if (!strncmp(ptr, SCMP("exit")))
267 | 			break;
268 |
269 | 		if (!strncmp(ptr, SCMP("mdb_env_create"))) {
270 | 			void *tenv;
271 | 			MDB_env *renv;
272 | 			sscanf(ptr+SOFF("mdb_env_create"), "%p", &tenv);
273 | 			E(mdb_env_create(&renv));
274 | 			addenv(tenv, renv);
275 | 		} else if (!strncmp(ptr, SCMP("mdb_env_set_maxdbs"))) {
276 | 			void *tenv;
277 | 			envpair *ep;
278 | 			unsigned int maxdbs;
279 | 			sscanf(ptr+SOFF("mdb_env_set_maxdbs"), "%p, %u", &tenv, &maxdbs);
280 | 			ep = findenv(tenv);
281 | 			E(mdb_env_set_maxdbs(ep->renv, maxdbs));
282 | 		} else if (!strncmp(ptr, SCMP("mdb_env_set_mapsize"))) {
283 | 			void *tenv;
284 | 			envpair *ep;
285 | 			mdb_size_t mapsize;
286 | 			sscanf(ptr+SOFF("mdb_env_set_mapsize"), "%p, %"MDB_SCNy(u), &tenv, &mapsize);
287 | 			ep = findenv(tenv);
288 | 			E(mdb_env_set_mapsize(ep->renv, mapsize));
289 | 		} else if (!strncmp(ptr, SCMP("mdb_env_open"))) {
290 | 			void *tenv;
291 | 			envpair *ep;
292 | 			char *path;
293 | 			int len;
294 | 			unsigned int flags, mode;
295 | 			sscanf(ptr+SOFF("mdb_env_open"), "%p, %n", &tenv, &len);
296 | 			path = ptr+SOFF("mdb_env_open")+len;
297 | 			ptr = strchr(path, ',');
298 | 			*ptr++ = '\0';
299 | 			sscanf(ptr, "%u, %o", &flags, &mode);
300 | 			ep = findenv(tenv);
301 | 			E(mdb_env_open(ep->renv, path, flags, mode));
302 | 			if (!maxkey) {
303 | 				maxkey = mdb_env_get_maxkeysize(ep->renv);
304 | 				kbuf = malloc(maxkey+2);
305 | 				dbuf = malloc(maxkey+2);
306 | 				dbufsize = maxkey;
307 | 			}
308 | 		} else if (!strncmp(ptr, SCMP("mdb_env_close"))) {
309 | 			void *tenv;
310 | 			envpair *ep;
311 | 			sscanf(ptr+SOFF("mdb_env_close"), "%p", &tenv);
312 | 			ep = findenv(tenv);
313 | 			mdb_env_close(ep->renv);
314 | 			delenv(ep);
315 | 			if (!nenvs)	/* if no other envs left, this process is done */
316 | 				break;
317 | 		} else if (!strncmp(ptr, SCMP("mdb_txn_begin"))) {
318 | 			unsigned int flags;
319 | 			void *tenv, *ttxn;
320 | 			envpair *ep;
321 | 			MDB_txn *rtxn;
322 | 			sscanf(ptr+SOFF("mdb_txn_begin"), "%p, %*p, %u = %p", &tenv, &flags, &ttxn);
323 | 			ep = findenv(tenv);
324 | 			E(mdb_txn_begin(ep->renv, NULL, flags, &rtxn));
325 | 			addtxn(tenv, ttxn, rtxn);
326 | 		} else if (!strncmp(ptr, SCMP("mdb_txn_commit"))) {
327 | 			void *ttxn;
328 | 			txnpair *tp;
329 | 			sscanf(ptr+SOFF("mdb_txn_commit"), "%p", &ttxn);
330 | 			tp = findtxn(ttxn);
331 | 			E(mdb_txn_commit(tp->rtxn));
332 | 			deltxn(tp);
333 | 		} else if (!strncmp(ptr, SCMP("mdb_txn_abort"))) {
334 | 			void *ttxn;
335 | 			txnpair *tp;
336 | 			sscanf(ptr+SOFF("mdb_txn_abort"), "%p", &ttxn);
337 | 			tp = findtxn(ttxn);
338 | 			mdb_txn_abort(tp->rtxn);
339 | 			deltxn(tp);
340 | 		} else if (!strncmp(ptr, SCMP("mdb_dbi_open"))) {
341 | 			void *ttxn;
342 | 			txnpair *tp;
343 | 			char *dbname;
344 | 			unsigned int flags;
345 | 			unsigned int tdbi;
346 | 			MDB_dbi dbi;
347 | 			sscanf(ptr+SOFF("mdb_dbi_open"), "%p, ", &ttxn);
348 | 			dbname = strchr(ptr+SOFF("mdb_dbi_open"), ',');
349 | 			dbname += 2;
350 | 			ptr = strchr(dbname, ',');
351 | 			*ptr++ = '\0';
352 | 			if (!strcmp(dbname, "(null)"))
353 | 				dbname = NULL;
354 | 			sscanf(ptr, "%u = %u", &flags, &tdbi);
355 | 			tp = findtxn(ttxn);
356 | 			E(mdb_dbi_open(tp->rtxn, dbname, flags, &dbi));
357 | 		} else if (!strncmp(ptr, SCMP("mdb_dbi_close"))) {
358 | 			void *tenv;
359 | 			envpair *ep;
360 | 			unsigned int tdbi;
361 | 			sscanf(ptr+SOFF("mdb_dbi_close"), "%p, %u", &tenv, &tdbi);
362 | 			ep = findenv(tenv);
363 | 			mdb_dbi_close(ep->renv, tdbi);
364 | 		} else if (!strncmp(ptr, SCMP("mdb_cursor_open"))) {
365 | 			void *ttxn, *tcrs;
366 | 			txnpair *tp;
367 | 			MDB_cursor *rcrs;
368 | 			unsigned int tdbi;
369 | 			sscanf(ptr+SOFF("mdb_cursor_open"), "%p, %u = %p", &ttxn, &tdbi, &tcrs);
370 | 			tp = findtxn(ttxn);
371 | 			E(mdb_cursor_open(tp->rtxn, tdbi, &rcrs));
372 | 			addcrs(tp, tcrs, rcrs);
373 | 		} else if (!strncmp(ptr, SCMP("mdb_cursor_close"))) {
374 | 			void *tcrs;
375 | 			sscanf(ptr+SOFF("mdb_cursor_close"), "%p", &tcrs);
376 | 			delcrs(tcrs);
377 | 		} else if (!strncmp(ptr, SCMP("mdb_cursor_put"))) {
378 | 			void *tcrs;
379 | 			crspair *cp;
380 | 			unsigned int flags;
381 | 			int len;
382 | 			sscanf(ptr+SOFF("mdb_cursor_put"), "%p, ", &tcrs);
383 | 			cp = findcrs(tcrs);
384 | 			ptr = strchr(ptr+SOFF("mdb_cursor_put"), ',');
385 | 			sscanf(ptr+1, "%"MDB_SCNy(u)",", &key.mv_size);
386 | 			if (key.mv_size) {
387 | 				ptr = strchr(ptr, '[');
388 | 				inhex(ptr+1, kbuf);
389 | 				key.mv_data = kbuf;
390 | 				ptr += key.mv_size * 2 + 2;
391 | 			}
392 | 			ptr = strchr(ptr+1, ',');
393 | 			sscanf(ptr+1, "%"MDB_SCNy(u)"%n", &data.mv_size, &len);
394 | 			if (data.mv_size > dbufsize) {
395 | 				dbuf = realloc(dbuf, data.mv_size+2);
396 | 				assert(dbuf != NULL);
397 | 				dbufsize = data.mv_size;
398 | 			}
399 | 			ptr += len+1;
400 | 			if (*ptr == '[') {
401 | 				inhex(ptr+1, dbuf);
402 | 				data.mv_data = dbuf;
403 | 				ptr += data.mv_size * 2 + 2;
404 | 			} else {
405 | 				sprintf(dbuf, "%09ld", (long)mdb_txn_id(lasttxn->rtxn));
406 | 			}
407 | 			sscanf(ptr+1, "%u", &flags);
408 | 			E(mdb_cursor_put(cp->rcrs, &key, &data, flags));
409 | 		} else if (!strncmp(ptr, SCMP("mdb_cursor_del"))) {
410 | 			void *tcrs;
411 | 			crspair *cp;
412 | 			unsigned int flags;
413 | 			sscanf(ptr+SOFF("mdb_cursor_del"), "%p, %u", &tcrs, &flags);
414 | 			cp = findcrs(tcrs);
415 | 			E(mdb_cursor_del(cp->rcrs, flags));
416 | 		} else if (!strncmp(ptr, SCMP("mdb_put"))) {
417 | 			void *ttxn;
418 | 			txnpair *tp;
419 | 			unsigned int tdbi, flags;
420 | 			int len;
421 | 			sscanf(ptr+SOFF("mdb_put"),"%p, %u, %"MDB_SCNy(u), &ttxn, &tdbi, &key.mv_size);
422 | 			tp = findtxn(ttxn);
423 | 			ptr = strchr(ptr+SOFF("mdb_put"), '[');
424 | 			inhex(ptr+1, kbuf);
425 | 			key.mv_data = kbuf;
426 | 			ptr += key.mv_size * 2 + 2;
427 | 			sscanf(ptr+1, "%"MDB_SCNy(u)"%n", &data.mv_size, &len);
428 | 			if (data.mv_size > dbufsize) {
429 | 				dbuf = realloc(dbuf, data.mv_size+2);
430 | 				assert(dbuf != NULL);
431 | 				dbufsize = data.mv_size;
432 | 			}
433 | 			ptr += len+1;
434 | 			if (*ptr == '[') {
435 | 				inhex(ptr+1, dbuf);
436 | 				ptr += data.mv_size * 2 + 2;
437 | 			} else {
438 | 				sprintf(dbuf, "%09ld", (long)mdb_txn_id(tp->rtxn));
439 | 			}
440 | 			data.mv_data = dbuf;
441 | 			sscanf(ptr+1, "%u", &flags);
442 | 			RES(MDB_KEYEXIST,mdb_put(tp->rtxn, tdbi, &key, &data, flags));
443 | 		} else if (!strncmp(ptr, SCMP("mdb_del"))) {
444 | 			void *ttxn;
445 | 			txnpair *tp;
446 | 			unsigned int tdbi;
447 | 			int len;
448 | 			sscanf(ptr+SOFF("mdb_del"),"%p, %u, %"MDB_SCNy(u), &ttxn, &tdbi, &key.mv_size);
449 | 			tp = findtxn(ttxn);
450 | 			ptr = strchr(ptr+SOFF("mdb_del"), '[');
451 | 			inhex(ptr+1, kbuf);
452 | 			key.mv_data = kbuf;
453 | 			ptr += key.mv_size * 2 + 2;
454 | 			sscanf(ptr+1, "%"MDB_SCNy(u)"%n", &data.mv_size, &len);
455 | 			if (data.mv_size > dbufsize) {
456 | 				dbuf = realloc(dbuf, data.mv_size+2);
457 | 				assert(dbuf != NULL);
458 | 				dbufsize = data.mv_size;
459 | 			}
460 | 			ptr += len+1;
461 | 			if (*ptr == '[') {
462 | 				inhex(ptr+1, dbuf);
463 | 			} else {
464 | 				sprintf(dbuf, "%09ld", (long)mdb_txn_id(tp->rtxn));
465 | 			}
466 | 			data.mv_data = dbuf;
467 | 			RES(MDB_NOTFOUND,mdb_del(tp->rtxn, tdbi, &key, &data));
468 | 		}
469 | 		write(1, "\n", 1);
470 | 	}
471 | 	exit(0);
472 | }
473 |
474 | static pidpair *addpid(int tpid)
475 | {
476 | 	int fdout[2], fdin[2];
477 | 	pid_t pid;
478 | 	assert(npids < MAXPIDS);
479 | 	pids[npids].tpid = tpid;
480 | 	pipe(fdout);
481 | 	pipe(fdin);
482 | 	if ((pid = fork()) == 0) {
483 | 		/* child */
484 | 		fclose(stdin);
485 | 		fclose(stdout);
486 | 		dup2(fdout[0], 0);
487 | 		dup2(fdin[1], 1);
488 | 		stdin = fdopen(0, "r");
489 | 		stdout = fdopen(1, "w");
490 | 		child();
491 | 		return 0;	/* NOTREACHED */
492 | 	} else {
493 | 		pids[npids].rpid = pid;
494 | 		pids[npids].fdout = fdout[1];
495 | 		pids[npids].fdin = fdin[0];
496 | 		lastpid = pids+npids;
497 | 		npids++;
498 | 		return lastpid;
499 | 	}
500 | }
501 |
502 | static pidpair *findpid(int tpid)
503 | {
504 | 	int i;
505 | 	if (!lastpid || lastpid->tpid != tpid) {
506 | 		for (i=0; i<npids; i++)
507 | 			if (pids[i].tpid == tpid)
508 | 				break;
509 | 		if (i == npids)
510 | 			return NULL;
511 | 		lastpid = &pids[i];
512 | 	}
513 | 	return lastpid;
514 | }
515 |
516 | volatile pid_t killpid;
517 |
518 | static void delpid(int tpid)
519 | {
520 | 	pidpair *pp = findpid(tpid);
521 | 	if (pp) {
522 | 		pid_t kpid = pp->rpid;
523 | 		killpid = kpid;
524 | 		write(pp->fdout, "exit\n", sizeof("exit"));
525 | 		while (killpid == kpid)
526 | 			usleep(10000);
527 | 	}
528 | }
529 |
530 | static void reaper(int sig)
531 | {
532 | 	int status, i;
533 | 	pid_t pid = waitpid(-1, &status, 0);
534 | 	if (pid > 0) {
535 | 		fprintf(stderr, "# %s %d\n", WIFEXITED(status) ? "exited" : "killed", pid);
536 | 		for (i=0; i<npids; i++)
537 | 			if (pids[i].rpid == pid)
538 | 				break;
539 | 		assert(i < npids);
540 | 		close(pids[i].fdout);
541 | 		close(pids[i].fdin);
542 | 		for (;i<npids-1; i++)
543 | 			pids[i] = pids[i+1];
544 | 		npids--;
545 | 		killpid = 0;
546 | 	}
547 | }
548 |
549 | int main(int argc,char * argv[])
550 | {
551 | 	signal(SIGCHLD, reaper);
552 |
553 | 	while (fgets(inbuf, sizeof(inbuf), stdin)) {
554 | 		pidpair *pp;
555 | 		int tpid, len;
556 | 		char c, *ptr;
557 | 		lcount++;
558 |
559 | 		if (inbuf[0] == '#' && !strncmp(inbuf+1, SCMP(" killed"))) {
560 | 			sscanf(inbuf+SOFF("killed"),"%d", &tpid);
561 | 			delpid(tpid);
562 | 			continue;
563 | 		}
564 |
565 | 		if (inbuf[0] != '>')
566 | 			continue;
567 | 		ptr = inbuf+1;
568 | 		sscanf(ptr, "%d:%n", &tpid, &len);
569 | 		pp = findpid(tpid);
570 | 		if (!pp)
571 | 			pp = addpid(tpid);	/* new process */
572 |
573 | 		ptr = inbuf+len+1;
574 | 		len = strlen(ptr);
575 | 		write(pp->fdout, ptr, len);	/* send command and wait for ack */
576 | 		read(pp->fdin, &c, 1);
577 | 	}
578 | 	while (npids)
579 | 		delpid(pids[0].tpid);
580 | }
581 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mtest.c:
--------------------------------------------------------------------------------
  1 | /* mtest.c - memory-mapped database tester/toy */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 | #include <stdio.h>
 15 | #include <stdlib.h>
 16 | #include <time.h>
 17 | #include "lmdb.h"
 18 |
 19 | #define E(expr) CHECK((rc = (expr)) == MDB_SUCCESS, #expr)
 20 | #define RES(err, expr) ((rc = expr) == (err) || (CHECK(!rc, #expr), 0))
 21 | #define CHECK(test, msg) ((test) ? (void)0 : ((void)fprintf(stderr, \
 22 | 	"%s:%d: %s: %s\n", __FILE__, __LINE__, msg, mdb_strerror(rc)), abort()))
 23 |
 24 | int main(int argc,char * argv[])
 25 | {
 26 | 	int i = 0, j = 0, rc;
 27 | 	MDB_env *env;
 28 | 	MDB_dbi dbi;
 29 | 	MDB_val key, data;
 30 | 	MDB_txn *txn;
 31 | 	MDB_stat mst;
 32 | 	MDB_cursor *cursor, *cur2;
 33 | 	MDB_cursor_op op;
 34 | 	int count;
 35 | 	int *values;
 36 | 	char sval[32] = "";
 37 |
 38 | 	srand(time(NULL));
 39 |
 40 | 	    count = (rand()%384) + 64;
 41 | 	    values = (int *)malloc(count*sizeof(int));
 42 |
 43 | 	    for(i = 0;i<count;i++) {
 44 | 			values[i] = rand()%1024;
 45 | 	    }
 46 |
 47 | 		E(mdb_env_create(&env));
 48 | 		E(mdb_env_set_maxreaders(env, 1));
 49 | 		E(mdb_env_set_mapsize(env, 10485760));
 50 | 		E(mdb_env_open(env, "./testdb", MDB_FIXEDMAP /*|MDB_NOSYNC*/, 0664));
 51 |
 52 | 		E(mdb_txn_begin(env, NULL, 0, &txn));
 53 | 		E(mdb_dbi_open(txn, NULL, 0, &dbi));
 54 |
 55 | 		key.mv_size = sizeof(int);
 56 | 		key.mv_data = sval;
 57 |
 58 | 		printf("Adding %d values\n", count);
 59 | 	    for (i=0;i<count;i++) {
 60 | 			sprintf(sval, "%03x %d foo bar", values[i], values[i]);
 61 | 			/* Set <data> in each iteration, since MDB_NOOVERWRITE may modify it */
 62 | 			data.mv_size = sizeof(sval);
 63 | 			data.mv_data = sval;
 64 | 			if (RES(MDB_KEYEXIST, mdb_put(txn, dbi, &key, &data, MDB_NOOVERWRITE))) {
 65 | 				j++;
 66 | 				data.mv_size = sizeof(sval);
 67 | 				data.mv_data = sval;
 68 | 			}
 69 | 	    }
 70 | 		if (j) printf("%d duplicates skipped\n", j);
 71 | 		E(mdb_txn_commit(txn));
 72 | 		E(mdb_env_stat(env, &mst));
 73 |
 74 | 		E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
 75 | 		E(mdb_cursor_open(txn, dbi, &cursor));
 76 | 		while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
 77 | 			printf("key: %p %.*s, data: %p %.*s\n",
 78 | 				key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
 79 | 				data.mv_data, (int) data.mv_size, (char *) data.mv_data);
 80 | 		}
 81 | 		CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
 82 | 		mdb_cursor_close(cursor);
 83 | 		mdb_txn_abort(txn);
 84 |
 85 | 		j=0;
 86 | 		key.mv_data = sval;
 87 | 	    for (i= count - 1; i > -1; i-= (rand()%5)) {
 88 | 			j++;
 89 | 			txn=NULL;
 90 | 			E(mdb_txn_begin(env, NULL, 0, &txn));
 91 | 			sprintf(sval, "%03x ", values[i]);
 92 | 			if (RES(MDB_NOTFOUND, mdb_del(txn, dbi, &key, NULL))) {
 93 | 				j--;
 94 | 				mdb_txn_abort(txn);
 95 | 			} else {
 96 | 				E(mdb_txn_commit(txn));
 97 | 			}
 98 | 	    }
 99 | 	    free(values);
100 | 		printf("Deleted %d values\n", j);
101 |
102 | 		E(mdb_env_stat(env, &mst));
103 | 		E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
104 | 		E(mdb_cursor_open(txn, dbi, &cursor));
105 | 		printf("Cursor next\n");
106 | 		while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
107 | 			printf("key: %.*s, data: %.*s\n",
108 | 				(int) key.mv_size,  (char *) key.mv_data,
109 | 				(int) data.mv_size, (char *) data.mv_data);
110 | 		}
111 | 		CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
112 | 		printf("Cursor last\n");
113 | 		E(mdb_cursor_get(cursor, &key, &data, MDB_LAST));
114 | 		printf("key: %.*s, data: %.*s\n",
115 | 			(int) key.mv_size,  (char *) key.mv_data,
116 | 			(int) data.mv_size, (char *) data.mv_data);
117 | 		printf("Cursor prev\n");
118 | 		while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_PREV)) == 0) {
119 | 			printf("key: %.*s, data: %.*s\n",
120 | 				(int) key.mv_size,  (char *) key.mv_data,
121 | 				(int) data.mv_size, (char *) data.mv_data);
122 | 		}
123 | 		CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
124 | 		printf("Cursor last/prev\n");
125 | 		E(mdb_cursor_get(cursor, &key, &data, MDB_LAST));
126 | 			printf("key: %.*s, data: %.*s\n",
127 | 				(int) key.mv_size,  (char *) key.mv_data,
128 | 				(int) data.mv_size, (char *) data.mv_data);
129 | 		E(mdb_cursor_get(cursor, &key, &data, MDB_PREV));
130 | 			printf("key: %.*s, data: %.*s\n",
131 | 				(int) key.mv_size,  (char *) key.mv_data,
132 | 				(int) data.mv_size, (char *) data.mv_data);
133 |
134 | 		mdb_cursor_close(cursor);
135 | 		mdb_txn_abort(txn);
136 |
137 | 		printf("Deleting with cursor\n");
138 | 		E(mdb_txn_begin(env, NULL, 0, &txn));
139 | 		E(mdb_cursor_open(txn, dbi, &cur2));
140 | 		for (i=0; i<50; i++) {
141 | 			if (RES(MDB_NOTFOUND, mdb_cursor_get(cur2, &key, &data, MDB_NEXT)))
142 | 				break;
143 | 			printf("key: %p %.*s, data: %p %.*s\n",
144 | 				key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
145 | 				data.mv_data, (int) data.mv_size, (char *) data.mv_data);
146 | 			E(mdb_del(txn, dbi, &key, NULL));
147 | 		}
148 |
149 | 		printf("Restarting cursor in txn\n");
150 | 		for (op=MDB_FIRST, i=0; i<=32; op=MDB_NEXT, i++) {
151 | 			if (RES(MDB_NOTFOUND, mdb_cursor_get(cur2, &key, &data, op)))
152 | 				break;
153 | 			printf("key: %p %.*s, data: %p %.*s\n",
154 | 				key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
155 | 				data.mv_data, (int) data.mv_size, (char *) data.mv_data);
156 | 		}
157 | 		mdb_cursor_close(cur2);
158 | 		E(mdb_txn_commit(txn));
159 |
160 | 		printf("Restarting cursor outside txn\n");
161 | 		E(mdb_txn_begin(env, NULL, 0, &txn));
162 | 		E(mdb_cursor_open(txn, dbi, &cursor));
163 | 		for (op=MDB_FIRST, i=0; i<=32; op=MDB_NEXT, i++) {
164 | 			if (RES(MDB_NOTFOUND, mdb_cursor_get(cursor, &key, &data, op)))
165 | 				break;
166 | 			printf("key: %p %.*s, data: %p %.*s\n",
167 | 				key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
168 | 				data.mv_data, (int) data.mv_size, (char *) data.mv_data);
169 | 		}
170 | 		mdb_cursor_close(cursor);
171 | 		mdb_txn_abort(txn);
172 |
173 | 		mdb_dbi_close(env, dbi);
174 | 		mdb_env_close(env);
175 |
176 | 	return 0;
177 | }
178 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mtest2.c:
--------------------------------------------------------------------------------
  1 | /* mtest2.c - memory-mapped database tester/toy */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 |
 15 | /* Just like mtest.c, but using a subDB instead of the main DB */
 16 |
 17 | #include <stdio.h>
 18 | #include <stdlib.h>
 19 | #include <time.h>
 20 | #include "lmdb.h"
 21 |
 22 | #define E(expr) CHECK((rc = (expr)) == MDB_SUCCESS, #expr)
 23 | #define RES(err, expr) ((rc = expr) == (err) || (CHECK(!rc, #expr), 0))
 24 | #define CHECK(test, msg) ((test) ? (void)0 : ((void)fprintf(stderr, \
 25 | 	"%s:%d: %s: %s\n", __FILE__, __LINE__, msg, mdb_strerror(rc)), abort()))
 26 |
 27 | int main(int argc,char * argv[])
 28 | {
 29 | 	int i = 0, j = 0, rc;
 30 | 	MDB_env *env;
 31 | 	MDB_dbi dbi;
 32 | 	MDB_val key, data;
 33 | 	MDB_txn *txn;
 34 | 	MDB_stat mst;
 35 | 	MDB_cursor *cursor;
 36 | 	int count;
 37 | 	int *values;
 38 | 	char sval[32] = "";
 39 |
 40 | 	srand(time(NULL));
 41 |
 42 | 	count = (rand()%384) + 64;
 43 | 	values = (int *)malloc(count*sizeof(int));
 44 |
 45 | 	for(i = 0;i<count;i++) {
 46 | 		values[i] = rand()%1024;
 47 | 	}
 48 |
 49 | 	E(mdb_env_create(&env));
 50 | 	E(mdb_env_set_maxreaders(env, 1));
 51 | 	E(mdb_env_set_mapsize(env, 10485760));
 52 | 	E(mdb_env_set_maxdbs(env, 4));
 53 | 	E(mdb_env_open(env, "./testdb", MDB_FIXEDMAP|MDB_NOSYNC, 0664));
 54 |
 55 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
 56 | 	E(mdb_dbi_open(txn, "id1", MDB_CREATE, &dbi));
 57 |
 58 | 	key.mv_size = sizeof(int);
 59 | 	key.mv_data = sval;
 60 |
 61 | 	printf("Adding %d values\n", count);
 62 | 	for (i=0;i<count;i++) {
 63 | 		sprintf(sval, "%03x %d foo bar", values[i], values[i]);
 64 | 		data.mv_size = sizeof(sval);
 65 | 		data.mv_data = sval;
 66 | 		if (RES(MDB_KEYEXIST, mdb_put(txn, dbi, &key, &data, MDB_NOOVERWRITE)))
 67 | 			j++;
 68 | 	}
 69 | 	if (j) printf("%d duplicates skipped\n", j);
 70 | 	E(mdb_txn_commit(txn));
 71 | 	E(mdb_env_stat(env, &mst));
 72 |
 73 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
 74 | 	E(mdb_cursor_open(txn, dbi, &cursor));
 75 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
 76 | 		printf("key: %p %.*s, data: %p %.*s\n",
 77 | 			key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
 78 | 			data.mv_data, (int) data.mv_size, (char *) data.mv_data);
 79 | 	}
 80 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
 81 | 	mdb_cursor_close(cursor);
 82 | 	mdb_txn_abort(txn);
 83 |
 84 | 	j=0;
 85 | 	key.mv_data = sval;
 86 | 	for (i= count - 1; i > -1; i-= (rand()%5)) {
 87 | 		j++;
 88 | 		txn=NULL;
 89 | 		E(mdb_txn_begin(env, NULL, 0, &txn));
 90 | 		sprintf(sval, "%03x ", values[i]);
 91 | 		if (RES(MDB_NOTFOUND, mdb_del(txn, dbi, &key, NULL))) {
 92 | 			j--;
 93 | 			mdb_txn_abort(txn);
 94 | 		} else {
 95 | 			E(mdb_txn_commit(txn));
 96 | 		}
 97 | 	}
 98 | 	free(values);
 99 | 	printf("Deleted %d values\n", j);
100 |
101 | 	E(mdb_env_stat(env, &mst));
102 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
103 | 	E(mdb_cursor_open(txn, dbi, &cursor));
104 | 	printf("Cursor next\n");
105 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
106 | 		printf("key: %.*s, data: %.*s\n",
107 | 			(int) key.mv_size,  (char *) key.mv_data,
108 | 			(int) data.mv_size, (char *) data.mv_data);
109 | 	}
110 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
111 | 	printf("Cursor prev\n");
112 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_PREV)) == 0) {
113 | 		printf("key: %.*s, data: %.*s\n",
114 | 			(int) key.mv_size,  (char *) key.mv_data,
115 | 			(int) data.mv_size, (char *) data.mv_data);
116 | 	}
117 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
118 | 	mdb_cursor_close(cursor);
119 | 	mdb_txn_abort(txn);
120 |
121 | 	mdb_dbi_close(env, dbi);
122 | 	mdb_env_close(env);
123 | 	return 0;
124 | }
125 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mtest3.c:
--------------------------------------------------------------------------------
  1 | /* mtest3.c - memory-mapped database tester/toy */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 |
 15 | /* Tests for sorted duplicate DBs */
 16 | #include <stdio.h>
 17 | #include <stdlib.h>
 18 | #include <string.h>
 19 | #include <time.h>
 20 | #include "lmdb.h"
 21 |
 22 | #define E(expr) CHECK((rc = (expr)) == MDB_SUCCESS, #expr)
 23 | #define RES(err, expr) ((rc = expr) == (err) || (CHECK(!rc, #expr), 0))
 24 | #define CHECK(test, msg) ((test) ? (void)0 : ((void)fprintf(stderr, \
 25 | 	"%s:%d: %s: %s\n", __FILE__, __LINE__, msg, mdb_strerror(rc)), abort()))
 26 |
 27 | int main(int argc,char * argv[])
 28 | {
 29 | 	int i = 0, j = 0, rc;
 30 | 	MDB_env *env;
 31 | 	MDB_dbi dbi;
 32 | 	MDB_val key, data;
 33 | 	MDB_txn *txn;
 34 | 	MDB_stat mst;
 35 | 	MDB_cursor *cursor;
 36 | 	int count;
 37 | 	int *values;
 38 | 	char sval[32];
 39 | 	char kval[sizeof(int)];
 40 |
 41 | 	srand(time(NULL));
 42 |
 43 | 	memset(sval, 0, sizeof(sval));
 44 |
 45 | 	count = (rand()%384) + 64;
 46 | 	values = (int *)malloc(count*sizeof(int));
 47 |
 48 | 	for(i = 0;i<count;i++) {
 49 | 		values[i] = rand()%1024;
 50 | 	}
 51 |
 52 | 	E(mdb_env_create(&env));
 53 | 	E(mdb_env_set_mapsize(env, 10485760));
 54 | 	E(mdb_env_set_maxdbs(env, 4));
 55 | 	E(mdb_env_open(env, "./testdb", MDB_FIXEDMAP|MDB_NOSYNC, 0664));
 56 |
 57 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
 58 | 	E(mdb_dbi_open(txn, "id2", MDB_CREATE|MDB_DUPSORT, &dbi));
 59 |
 60 | 	key.mv_size = sizeof(int);
 61 | 	key.mv_data = kval;
 62 | 	data.mv_size = sizeof(sval);
 63 | 	data.mv_data = sval;
 64 |
 65 | 	printf("Adding %d values\n", count);
 66 | 	for (i=0;i<count;i++) {
 67 | 		if (!(i & 0x0f))
 68 | 			sprintf(kval, "%03x", values[i]);
 69 | 		sprintf(sval, "%03x %d foo bar", values[i], values[i]);
 70 | 		if (RES(MDB_KEYEXIST, mdb_put(txn, dbi, &key, &data, MDB_NODUPDATA)))
 71 | 			j++;
 72 | 	}
 73 | 	if (j) printf("%d duplicates skipped\n", j);
 74 | 	E(mdb_txn_commit(txn));
 75 | 	E(mdb_env_stat(env, &mst));
 76 |
 77 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
 78 | 	E(mdb_cursor_open(txn, dbi, &cursor));
 79 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
 80 | 		printf("key: %p %.*s, data: %p %.*s\n",
 81 | 			key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
 82 | 			data.mv_data, (int) data.mv_size, (char *) data.mv_data);
 83 | 	}
 84 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
 85 | 	mdb_cursor_close(cursor);
 86 | 	mdb_txn_abort(txn);
 87 |
 88 | 	j=0;
 89 |
 90 | 	for (i= count - 1; i > -1; i-= (rand()%5)) {
 91 | 		j++;
 92 | 		txn=NULL;
 93 | 		E(mdb_txn_begin(env, NULL, 0, &txn));
 94 | 		sprintf(kval, "%03x", values[i & ~0x0f]);
 95 | 		sprintf(sval, "%03x %d foo bar", values[i], values[i]);
 96 | 		key.mv_size = sizeof(int);
 97 | 		key.mv_data = kval;
 98 | 		data.mv_size = sizeof(sval);
 99 | 		data.mv_data = sval;
100 | 		if (RES(MDB_NOTFOUND, mdb_del(txn, dbi, &key, &data))) {
101 | 			j--;
102 | 			mdb_txn_abort(txn);
103 | 		} else {
104 | 			E(mdb_txn_commit(txn));
105 | 		}
106 | 	}
107 | 	free(values);
108 | 	printf("Deleted %d values\n", j);
109 |
110 | 	E(mdb_env_stat(env, &mst));
111 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
112 | 	E(mdb_cursor_open(txn, dbi, &cursor));
113 | 	printf("Cursor next\n");
114 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
115 | 		printf("key: %.*s, data: %.*s\n",
116 | 			(int) key.mv_size,  (char *) key.mv_data,
117 | 			(int) data.mv_size, (char *) data.mv_data);
118 | 	}
119 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
120 | 	printf("Cursor prev\n");
121 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_PREV)) == 0) {
122 | 		printf("key: %.*s, data: %.*s\n",
123 | 			(int) key.mv_size,  (char *) key.mv_data,
124 | 			(int) data.mv_size, (char *) data.mv_data);
125 | 	}
126 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
127 | 	mdb_cursor_close(cursor);
128 | 	mdb_txn_abort(txn);
129 |
130 | 	mdb_dbi_close(env, dbi);
131 | 	mdb_env_close(env);
132 | 	return 0;
133 | }
134 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mtest4.c:
--------------------------------------------------------------------------------
  1 | /* mtest4.c - memory-mapped database tester/toy */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 |
 15 | /* Tests for sorted duplicate DBs with fixed-size keys */
 16 | #include <stdio.h>
 17 | #include <stdlib.h>
 18 | #include <string.h>
 19 | #include <time.h>
 20 | #include "lmdb.h"
 21 |
 22 | #define E(expr) CHECK((rc = (expr)) == MDB_SUCCESS, #expr)
 23 | #define RES(err, expr) ((rc = expr) == (err) || (CHECK(!rc, #expr), 0))
 24 | #define CHECK(test, msg) ((test) ? (void)0 : ((void)fprintf(stderr, \
 25 | 	"%s:%d: %s: %s\n", __FILE__, __LINE__, msg, mdb_strerror(rc)), abort()))
 26 |
 27 | int main(int argc,char * argv[])
 28 | {
 29 | 	int i = 0, j = 0, rc;
 30 | 	MDB_env *env;
 31 | 	MDB_dbi dbi;
 32 | 	MDB_val key, data;
 33 | 	MDB_txn *txn;
 34 | 	MDB_stat mst;
 35 | 	MDB_cursor *cursor;
 36 | 	int count;
 37 | 	int *values;
 38 | 	char sval[8];
 39 | 	char kval[sizeof(int)];
 40 |
 41 | 	memset(sval, 0, sizeof(sval));
 42 |
 43 | 	count = 510;
 44 | 	values = (int *)malloc(count*sizeof(int));
 45 |
 46 | 	for(i = 0;i<count;i++) {
 47 | 		values[i] = i*5;
 48 | 	}
 49 |
 50 | 	E(mdb_env_create(&env));
 51 | 	E(mdb_env_set_mapsize(env, 10485760));
 52 | 	E(mdb_env_set_maxdbs(env, 4));
 53 | 	E(mdb_env_open(env, "./testdb", MDB_FIXEDMAP|MDB_NOSYNC, 0664));
 54 |
 55 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
 56 | 	E(mdb_dbi_open(txn, "id4", MDB_CREATE|MDB_DUPSORT|MDB_DUPFIXED, &dbi));
 57 |
 58 | 	key.mv_size = sizeof(int);
 59 | 	key.mv_data = kval;
 60 | 	data.mv_size = sizeof(sval);
 61 | 	data.mv_data = sval;
 62 |
 63 | 	printf("Adding %d values\n", count);
 64 | 	strcpy(kval, "001");
 65 | 	for (i=0;i<count;i++) {
 66 | 		sprintf(sval, "%07x", values[i]);
 67 | 		if (RES(MDB_KEYEXIST, mdb_put(txn, dbi, &key, &data, MDB_NODUPDATA)))
 68 | 			j++;
 69 | 	}
 70 | 	if (j) printf("%d duplicates skipped\n", j);
 71 | 	E(mdb_txn_commit(txn));
 72 | 	E(mdb_env_stat(env, &mst));
 73 |
 74 | 	/* there should be one full page of dups now.
 75 | 	 */
 76 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
 77 | 	E(mdb_cursor_open(txn, dbi, &cursor));
 78 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
 79 | 		printf("key: %p %.*s, data: %p %.*s\n",
 80 | 			key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
 81 | 			data.mv_data, (int) data.mv_size, (char *) data.mv_data);
 82 | 	}
 83 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
 84 | 	mdb_cursor_close(cursor);
 85 | 	mdb_txn_abort(txn);
 86 |
 87 | 	/* test all 3 branches of split code:
 88 | 	 * 1: new key in lower half
 89 | 	 * 2: new key at split point
 90 | 	 * 3: new key in upper half
 91 | 	 */
 92 |
 93 | 	key.mv_size = sizeof(int);
 94 | 	key.mv_data = kval;
 95 | 	data.mv_size = sizeof(sval);
 96 | 	data.mv_data = sval;
 97 |
 98 | 	sprintf(sval, "%07x", values[3]+1);
 99 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
100 | 	(void)RES(MDB_KEYEXIST, mdb_put(txn, dbi, &key, &data, MDB_NODUPDATA));
101 | 	mdb_txn_abort(txn);
102 |
103 | 	sprintf(sval, "%07x", values[255]+1);
104 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
105 | 	(void)RES(MDB_KEYEXIST, mdb_put(txn, dbi, &key, &data, MDB_NODUPDATA));
106 | 	mdb_txn_abort(txn);
107 |
108 | 	sprintf(sval, "%07x", values[500]+1);
109 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
110 | 	(void)RES(MDB_KEYEXIST, mdb_put(txn, dbi, &key, &data, MDB_NODUPDATA));
111 | 	E(mdb_txn_commit(txn));
112 |
113 | 	/* Try MDB_NEXT_MULTIPLE */
114 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
115 | 	E(mdb_cursor_open(txn, dbi, &cursor));
116 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT_MULTIPLE)) == 0) {
117 | 		printf("key: %.*s, data: %.*s\n",
118 | 			(int) key.mv_size,  (char *) key.mv_data,
119 | 			(int) data.mv_size, (char *) data.mv_data);
120 | 	}
121 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
122 | 	mdb_cursor_close(cursor);
123 | 	mdb_txn_abort(txn);
124 | 	j=0;
125 |
126 | 	for (i= count - 1; i > -1; i-= (rand()%3)) {
127 | 		j++;
128 | 		txn=NULL;
129 | 		E(mdb_txn_begin(env, NULL, 0, &txn));
130 | 		sprintf(sval, "%07x", values[i]);
131 | 		key.mv_size = sizeof(int);
132 | 		key.mv_data = kval;
133 | 		data.mv_size = sizeof(sval);
134 | 		data.mv_data = sval;
135 | 		if (RES(MDB_NOTFOUND, mdb_del(txn, dbi, &key, &data))) {
136 | 			j--;
137 | 			mdb_txn_abort(txn);
138 | 		} else {
139 | 			E(mdb_txn_commit(txn));
140 | 		}
141 | 	}
142 | 	free(values);
143 | 	printf("Deleted %d values\n", j);
144 |
145 | 	E(mdb_env_stat(env, &mst));
146 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
147 | 	E(mdb_cursor_open(txn, dbi, &cursor));
148 | 	printf("Cursor next\n");
149 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
150 | 		printf("key: %.*s, data: %.*s\n",
151 | 			(int) key.mv_size,  (char *) key.mv_data,
152 | 			(int) data.mv_size, (char *) data.mv_data);
153 | 	}
154 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
155 | 	printf("Cursor prev\n");
156 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_PREV)) == 0) {
157 | 		printf("key: %.*s, data: %.*s\n",
158 | 			(int) key.mv_size,  (char *) key.mv_data,
159 | 			(int) data.mv_size, (char *) data.mv_data);
160 | 	}
161 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
162 | 	mdb_cursor_close(cursor);
163 | 	mdb_txn_abort(txn);
164 |
165 | 	mdb_dbi_close(env, dbi);
166 | 	mdb_env_close(env);
167 | 	return 0;
168 | }
169 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mtest5.c:
--------------------------------------------------------------------------------
  1 | /* mtest5.c - memory-mapped database tester/toy */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 |
 15 | /* Tests for sorted duplicate DBs using cursor_put */
 16 | #include <stdio.h>
 17 | #include <stdlib.h>
 18 | #include <string.h>
 19 | #include <time.h>
 20 | #include "lmdb.h"
 21 |
 22 | #define E(expr) CHECK((rc = (expr)) == MDB_SUCCESS, #expr)
 23 | #define RES(err, expr) ((rc = expr) == (err) || (CHECK(!rc, #expr), 0))
 24 | #define CHECK(test, msg) ((test) ? (void)0 : ((void)fprintf(stderr, \
 25 | 	"%s:%d: %s: %s\n", __FILE__, __LINE__, msg, mdb_strerror(rc)), abort()))
 26 |
 27 | int main(int argc,char * argv[])
 28 | {
 29 | 	int i = 0, j = 0, rc;
 30 | 	MDB_env *env;
 31 | 	MDB_dbi dbi;
 32 | 	MDB_val key, data;
 33 | 	MDB_txn *txn;
 34 | 	MDB_stat mst;
 35 | 	MDB_cursor *cursor;
 36 | 	int count;
 37 | 	int *values;
 38 | 	char sval[32];
 39 | 	char kval[sizeof(int)];
 40 |
 41 | 	srand(time(NULL));
 42 |
 43 | 	memset(sval, 0, sizeof(sval));
 44 |
 45 | 	count = (rand()%384) + 64;
 46 | 	values = (int *)malloc(count*sizeof(int));
 47 |
 48 | 	for(i = 0;i<count;i++) {
 49 | 		values[i] = rand()%1024;
 50 | 	}
 51 |
 52 | 	E(mdb_env_create(&env));
 53 | 	E(mdb_env_set_mapsize(env, 10485760));
 54 | 	E(mdb_env_set_maxdbs(env, 4));
 55 | 	E(mdb_env_open(env, "./testdb", MDB_FIXEDMAP|MDB_NOSYNC, 0664));
 56 |
 57 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
 58 | 	E(mdb_dbi_open(txn, "id2", MDB_CREATE|MDB_DUPSORT, &dbi));
 59 | 	E(mdb_cursor_open(txn, dbi, &cursor));
 60 |
 61 | 	key.mv_size = sizeof(int);
 62 | 	key.mv_data = kval;
 63 | 	data.mv_size = sizeof(sval);
 64 | 	data.mv_data = sval;
 65 |
 66 | 	printf("Adding %d values\n", count);
 67 | 	for (i=0;i<count;i++) {
 68 | 		if (!(i & 0x0f))
 69 | 			sprintf(kval, "%03x", values[i]);
 70 | 		sprintf(sval, "%03x %d foo bar", values[i], values[i]);
 71 | 		if (RES(MDB_KEYEXIST, mdb_cursor_put(cursor, &key, &data, MDB_NODUPDATA)))
 72 | 			j++;
 73 | 	}
 74 | 	if (j) printf("%d duplicates skipped\n", j);
 75 | 	mdb_cursor_close(cursor);
 76 | 	E(mdb_txn_commit(txn));
 77 | 	E(mdb_env_stat(env, &mst));
 78 |
 79 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
 80 | 	E(mdb_cursor_open(txn, dbi, &cursor));
 81 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
 82 | 		printf("key: %p %.*s, data: %p %.*s\n",
 83 | 			key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
 84 | 			data.mv_data, (int) data.mv_size, (char *) data.mv_data);
 85 | 	}
 86 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
 87 | 	mdb_cursor_close(cursor);
 88 | 	mdb_txn_abort(txn);
 89 |
 90 | 	j=0;
 91 |
 92 | 	for (i= count - 1; i > -1; i-= (rand()%5)) {
 93 | 		j++;
 94 | 		txn=NULL;
 95 | 		E(mdb_txn_begin(env, NULL, 0, &txn));
 96 | 		sprintf(kval, "%03x", values[i & ~0x0f]);
 97 | 		sprintf(sval, "%03x %d foo bar", values[i], values[i]);
 98 | 		key.mv_size = sizeof(int);
 99 | 		key.mv_data = kval;
100 | 		data.mv_size = sizeof(sval);
101 | 		data.mv_data = sval;
102 | 		if (RES(MDB_NOTFOUND, mdb_del(txn, dbi, &key, &data))) {
103 | 			j--;
104 | 			mdb_txn_abort(txn);
105 | 		} else {
106 | 			E(mdb_txn_commit(txn));
107 | 		}
108 | 	}
109 | 	free(values);
110 | 	printf("Deleted %d values\n", j);
111 |
112 | 	E(mdb_env_stat(env, &mst));
113 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
114 | 	E(mdb_cursor_open(txn, dbi, &cursor));
115 | 	printf("Cursor next\n");
116 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
117 | 		printf("key: %.*s, data: %.*s\n",
118 | 			(int) key.mv_size,  (char *) key.mv_data,
119 | 			(int) data.mv_size, (char *) data.mv_data);
120 | 	}
121 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
122 | 	printf("Cursor prev\n");
123 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_PREV)) == 0) {
124 | 		printf("key: %.*s, data: %.*s\n",
125 | 			(int) key.mv_size,  (char *) key.mv_data,
126 | 			(int) data.mv_size, (char *) data.mv_data);
127 | 	}
128 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
129 | 	mdb_cursor_close(cursor);
130 | 	mdb_txn_abort(txn);
131 |
132 | 	mdb_dbi_close(env, dbi);
133 | 	mdb_env_close(env);
134 | 	return 0;
135 | }
136 |


--------------------------------------------------------------------------------
/libraries/liblmdb/mtest6.c:
--------------------------------------------------------------------------------
  1 | /* mtest6.c - memory-mapped database tester/toy */
  2 | /*
  3 |  * Copyright 2011-2021 Howard Chu, Symas Corp.
  4 |  * All rights reserved.
  5 |  *
  6 |  * Redistribution and use in source and binary forms, with or without
  7 |  * modification, are permitted only as authorized by the OpenLDAP
  8 |  * Public License.
  9 |  *
 10 |  * A copy of this license is available in the file LICENSE in the
 11 |  * top-level directory of the distribution or, alternatively, at
 12 |  * <http://www.OpenLDAP.org/license.html>.
 13 |  */
 14 |
 15 | /* Tests for DB splits and merges */
 16 | #include <stdio.h>
 17 | #include <stdlib.h>
 18 | #include <string.h>
 19 | #include <time.h>
 20 | #include "lmdb.h"
 21 |
 22 | #define E(expr) CHECK((rc = (expr)) == MDB_SUCCESS, #expr)
 23 | #define RES(err, expr) ((rc = expr) == (err) || (CHECK(!rc, #expr), 0))
 24 | #define CHECK(test, msg) ((test) ? (void)0 : ((void)fprintf(stderr, \
 25 | 	"%s:%d: %s: %s\n", __FILE__, __LINE__, msg, mdb_strerror(rc)), abort()))
 26 |
 27 | char dkbuf[1024];
 28 |
 29 | int main(int argc,char * argv[])
 30 | {
 31 | 	int i = 0, j = 0, rc;
 32 | 	MDB_env *env;
 33 | 	MDB_dbi dbi;
 34 | 	MDB_val key, data, sdata;
 35 | 	MDB_txn *txn;
 36 | 	MDB_stat mst;
 37 | 	MDB_cursor *cursor;
 38 | 	int count;
 39 | 	int *values;
 40 | 	long kval;
 41 | 	char *sval;
 42 |
 43 | 	srand(time(NULL));
 44 |
 45 | 	E(mdb_env_create(&env));
 46 | 	E(mdb_env_set_mapsize(env, 10485760));
 47 | 	E(mdb_env_set_maxdbs(env, 4));
 48 | 	E(mdb_env_open(env, "./testdb", MDB_FIXEDMAP|MDB_NOSYNC, 0664));
 49 |
 50 | 	E(mdb_txn_begin(env, NULL, 0, &txn));
 51 | 	E(mdb_dbi_open(txn, "id6", MDB_CREATE|MDB_INTEGERKEY, &dbi));
 52 | 	E(mdb_cursor_open(txn, dbi, &cursor));
 53 | 	E(mdb_stat(txn, dbi, &mst));
 54 |
 55 | 	sval = calloc(1, mst.ms_psize / 4);
 56 | 	key.mv_size = sizeof(long);
 57 | 	key.mv_data = &kval;
 58 | 	sdata.mv_size = mst.ms_psize / 4 - 30;
 59 | 	sdata.mv_data = sval;
 60 |
 61 | 	printf("Adding 12 values, should yield 3 splits\n");
 62 | 	for (i=0;i<12;i++) {
 63 | 		kval = i*5;
 64 | 		sprintf(sval, "%08x", kval);
 65 | 		data = sdata;
 66 | 		(void)RES(MDB_KEYEXIST, mdb_cursor_put(cursor, &key, &data, MDB_NOOVERWRITE));
 67 | 	}
 68 | 	printf("Adding 12 more values, should yield 3 splits\n");
 69 | 	for (i=0;i<12;i++) {
 70 | 		kval = i*5+4;
 71 | 		sprintf(sval, "%08x", kval);
 72 | 		data = sdata;
 73 | 		(void)RES(MDB_KEYEXIST, mdb_cursor_put(cursor, &key, &data, MDB_NOOVERWRITE));
 74 | 	}
 75 | 	printf("Adding 12 more values, should yield 3 splits\n");
 76 | 	for (i=0;i<12;i++) {
 77 | 		kval = i*5+1;
 78 | 		sprintf(sval, "%08x", kval);
 79 | 		data = sdata;
 80 | 		(void)RES(MDB_KEYEXIST, mdb_cursor_put(cursor, &key, &data, MDB_NOOVERWRITE));
 81 | 	}
 82 | 	E(mdb_cursor_get(cursor, &key, &data, MDB_FIRST));
 83 |
 84 | 	do {
 85 | 		printf("key: %p %s, data: %p %.*s\n",
 86 | 			key.mv_data,  mdb_dkey(&key, dkbuf),
 87 | 			data.mv_data, (int) data.mv_size, (char *) data.mv_data);
 88 | 	} while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0);
 89 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
 90 | 	mdb_cursor_close(cursor);
 91 | 	mdb_txn_commit(txn);
 92 |
 93 | #if 0
 94 | 	j=0;
 95 |
 96 | 	for (i= count - 1; i > -1; i-= (rand()%5)) {
 97 | 		j++;
 98 | 		txn=NULL;
 99 | 		E(mdb_txn_begin(env, NULL, 0, &txn));
100 | 		sprintf(kval, "%03x", values[i & ~0x0f]);
101 | 		sprintf(sval, "%03x %d foo bar", values[i], values[i]);
102 | 		key.mv_size = sizeof(int);
103 | 		key.mv_data = kval;
104 | 		data.mv_size = sizeof(sval);
105 | 		data.mv_data = sval;
106 | 		if (RES(MDB_NOTFOUND, mdb_del(txn, dbi, &key, &data))) {
107 | 			j--;
108 | 			mdb_txn_abort(txn);
109 | 		} else {
110 | 			E(mdb_txn_commit(txn));
111 | 		}
112 | 	}
113 | 	free(values);
114 | 	printf("Deleted %d values\n", j);
115 |
116 | 	E(mdb_env_stat(env, &mst));
117 | 	E(mdb_txn_begin(env, NULL, MDB_RDONLY, &txn));
118 | 	E(mdb_cursor_open(txn, dbi, &cursor));
119 | 	printf("Cursor next\n");
120 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
121 | 		printf("key: %.*s, data: %.*s\n",
122 | 			(int) key.mv_size,  (char *) key.mv_data,
123 | 			(int) data.mv_size, (char *) data.mv_data);
124 | 	}
125 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
126 | 	printf("Cursor prev\n");
127 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_PREV)) == 0) {
128 | 		printf("key: %.*s, data: %.*s\n",
129 | 			(int) key.mv_size,  (char *) key.mv_data,
130 | 			(int) data.mv_size, (char *) data.mv_data);
131 | 	}
132 | 	CHECK(rc == MDB_NOTFOUND, "mdb_cursor_get");
133 | 	mdb_cursor_close(cursor);
134 | 	mdb_txn_abort(txn);
135 |
136 | 	mdb_dbi_close(env, dbi);
137 | #endif
138 | 	mdb_env_close(env);
139 |
140 | 	return 0;
141 | }
142 |


--------------------------------------------------------------------------------
/libraries/liblmdb/sample-bdb.txt:
--------------------------------------------------------------------------------
 1 | /* sample-bdb.txt - BerkeleyDB toy/sample
 2 |  *
 3 |  * Do a line-by-line comparison of this and sample-mdb.txt
 4 |  */
 5 | /*
 6 |  * Copyright 2012-2021 Howard Chu, Symas Corp.
 7 |  * All rights reserved.
 8 |  *
 9 |  * Redistribution and use in source and binary forms, with or without
10 |  * modification, are permitted only as authorized by the OpenLDAP
11 |  * Public License.
12 |  *
13 |  * A copy of this license is available in the file LICENSE in the
14 |  * top-level directory of the distribution or, alternatively, at
15 |  * <http://www.OpenLDAP.org/license.html>.
16 |  */
17 | #include <stdio.h>
18 | #include <string.h>
19 | #include <db.h>
20 |
21 | int main(int argc,char * argv[])
22 | {
23 | 	int rc;
24 | 	DB_ENV *env;
25 | 	DB *dbi;
26 | 	DBT key, data;
27 | 	DB_TXN *txn;
28 | 	DBC *cursor;
29 | 	char sval[32], kval[32];
30 |
31 | 	/* Note: Most error checking omitted for simplicity */
32 |
33 | #define FLAGS (DB_INIT_LOCK|DB_INIT_LOG|DB_INIT_TXN|DB_INIT_MPOOL|DB_CREATE|DB_THREAD)
34 | 	rc = db_env_create(&env, 0);
35 | 	rc = env->open(env, "./testdb", FLAGS, 0664);
36 | 	rc = db_create(&dbi, env, 0);
37 | 	rc = env->txn_begin(env, NULL, &txn, 0);
38 | 	rc = dbi->open(dbi, txn, "test.bdb", NULL, DB_BTREE, DB_CREATE, 0664);
39 |
40 | 	memset(&key, 0, sizeof(DBT));
41 | 	memset(&data, 0, sizeof(DBT));
42 | 	key.size = sizeof(int);
43 | 	key.data = sval;
44 | 	data.size = sizeof(sval);
45 | 	data.data = sval;
46 |
47 | 	sprintf(sval, "%03x %d foo bar", 32, 3141592);
48 | 	rc = dbi->put(dbi, txn, &key, &data, 0);
49 | 	rc = txn->commit(txn, 0);
50 | 	if (rc) {
51 | 		fprintf(stderr, "txn->commit: (%d) %s\n", rc, db_strerror(rc));
52 | 		goto leave;
53 | 	}
54 | 	rc = env->txn_begin(env, NULL, &txn, 0);
55 | 	rc = dbi->cursor(dbi, txn, &cursor, 0);
56 | 	key.flags = DB_DBT_USERMEM;
57 | 	key.data = kval;
58 | 	key.ulen = sizeof(kval);
59 | 	data.flags = DB_DBT_USERMEM;
60 | 	data.data = sval;
61 | 	data.ulen = sizeof(sval);
62 | 	while ((rc = cursor->c_get(cursor, &key, &data, DB_NEXT)) == 0) {
63 | 		printf("key: %p %.*s, data: %p %.*s\n",
64 | 			key.data,  (int) key.size,  (char *) key.data,
65 | 			data.data, (int) data.size, (char *) data.data);
66 | 	}
67 | 	rc = cursor->c_close(cursor);
68 | 	rc = txn->abort(txn);
69 | leave:
70 | 	rc = dbi->close(dbi, 0);
71 | 	rc = env->close(env, 0);
72 | 	return rc;
73 | }
74 |


--------------------------------------------------------------------------------
/libraries/liblmdb/sample-mdb.txt:
--------------------------------------------------------------------------------
 1 | /* sample-mdb.txt - MDB toy/sample
 2 |  *
 3 |  * Do a line-by-line comparison of this and sample-bdb.txt
 4 |  */
 5 | /*
 6 |  * Copyright 2012-2021 Howard Chu, Symas Corp.
 7 |  * All rights reserved.
 8 |  *
 9 |  * Redistribution and use in source and binary forms, with or without
10 |  * modification, are permitted only as authorized by the OpenLDAP
11 |  * Public License.
12 |  *
13 |  * A copy of this license is available in the file LICENSE in the
14 |  * top-level directory of the distribution or, alternatively, at
15 |  * <http://www.OpenLDAP.org/license.html>.
16 |  */
17 | #include <stdio.h>
18 | #include "lmdb.h"
19 |
20 | int main(int argc,char * argv[])
21 | {
22 | 	int rc;
23 | 	MDB_env *env;
24 | 	MDB_dbi dbi;
25 | 	MDB_val key, data;
26 | 	MDB_txn *txn;
27 | 	MDB_cursor *cursor;
28 | 	char sval[32];
29 |
30 | 	/* Note: Most error checking omitted for simplicity */
31 |
32 | 	rc = mdb_env_create(&env);
33 | 	rc = mdb_env_open(env, "./testdb", 0, 0664);
34 | 	rc = mdb_txn_begin(env, NULL, 0, &txn);
35 | 	rc = mdb_dbi_open(txn, NULL, 0, &dbi);
36 |
37 | 	key.mv_size = sizeof(int);
38 | 	key.mv_data = sval;
39 | 	data.mv_size = sizeof(sval);
40 | 	data.mv_data = sval;
41 |
42 | 	sprintf(sval, "%03x %d foo bar", 32, 3141592);
43 | 	rc = mdb_put(txn, dbi, &key, &data, 0);
44 | 	rc = mdb_txn_commit(txn);
45 | 	if (rc) {
46 | 		fprintf(stderr, "mdb_txn_commit: (%d) %s\n", rc, mdb_strerror(rc));
47 | 		goto leave;
48 | 	}
49 | 	rc = mdb_txn_begin(env, NULL, MDB_RDONLY, &txn);
50 | 	rc = mdb_cursor_open(txn, dbi, &cursor);
51 | 	while ((rc = mdb_cursor_get(cursor, &key, &data, MDB_NEXT)) == 0) {
52 | 		printf("key: %p %.*s, data: %p %.*s\n",
53 | 			key.mv_data,  (int) key.mv_size,  (char *) key.mv_data,
54 | 			data.mv_data, (int) data.mv_size, (char *) data.mv_data);
55 | 	}
56 | 	mdb_cursor_close(cursor);
57 | 	mdb_txn_abort(txn);
58 | leave:
59 | 	mdb_dbi_close(env, dbi);
60 | 	mdb_env_close(env);
61 | 	return 0;
62 | }
63 |


--------------------------------------------------------------------------------
/libraries/liblmdb/tooltag:
--------------------------------------------------------------------------------
 1 | <tagfile>
 2 |   <compound kind="page">
 3 |     <name>mdb_copy_1</name>
 4 | 	<title>mdb_copy - environment copy tool</title>
 5 | 	<filename>mdb_copy.1</filename>
 6 |   </compound>
 7 |   <compound kind="page">
 8 |     <name>mdb_drop_1</name>
 9 | 	<title>mdb_drop - database delete tool</title>
10 | 	<filename>mdb_drop.1</filename>
11 |   </compound>
12 |   <compound kind="page">
13 |     <name>mdb_dump_1</name>
14 | 	<title>mdb_dump - environment export tool</title>
15 | 	<filename>mdb_dump.1</filename>
16 |   </compound>
17 |   <compound kind="page">
18 |     <name>mdb_load_1</name>
19 | 	<title>mdb_load - environment import tool</title>
20 | 	<filename>mdb_load.1</filename>
21 |   </compound>
22 |   <compound kind="page">
23 |     <name>mdb_stat_1</name>
24 | 	<title>mdb_stat - environment status tool</title>
25 | 	<filename>mdb_stat.1</filename>
26 |   </compound>
27 | </tagfile>
28 |


--------------------------------------------------------------------------------